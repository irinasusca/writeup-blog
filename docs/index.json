[{"content":"Challenge overview Undefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse this program to identify how you can get to the flag.\nAt first glance, the vuln looks like a 32-bit executable with a buffer overflow vulnerability.\nAnalyzing the binary, we come across some interesting funtions, UnderConstruction and win.\nAfter a quick checksec, we find vuln has both NX and a stack canary enabled. So we can probably find a way to leak the stack canary using the UnderConstruction function.\nIdentifying the vulnerabilities We can easily buffer overflow (the offset I used was 14 of \\x90 padding and then I set the new eip as 0x8049E10, the beginning of UnderConstruction) into UnderConstruction, and we get a bunch of leaks:\nIt doesn\u0026rsquo;t seem like the stack canary is very effective. If we overwrite eip with the win function, it does indeed enter win, but no flag seems to be getting printed. Let\u0026rsquo;s analyze it further:\nAha! So if we look closely, what this does is it saves the flag in the stack, and if the flag array is null, it executes a _printf(%s %s);.\nIn my case, I have a flag.txt file created locally, so it doesn\u0026rsquo;t really output anything at all. What it does do though, is save the flag in the stack (also hinted by the challenge name, stack cache).\nWe can see the content of flag.txt being pushed on the stack.\nThe next logical step is making it so that the function called after win is UnderConstruction. We can do this without much hassle since we are working on a 32-bit executable, so no need to work with registers.\nThe stack alignment for 32-bit is function, parameters, return address and since these functions don\u0026rsquo;t need any params we can easily chain a bunch of functions.\npayload = b\u0026#39;\\x90\u0026#39;*14 payload += p32(0x8049D90) #win payload += p32(0x8049E10) #under constr devine ret addr la win payload += p32(0x8049E10) #a bunch of undr constr to leak the flag payload += p32(0x8049E10) #to get a bunch of %p \u0026#39;s payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049EB0) #main Since I wanted to make sure that we would get all of the flag, not just a part of it, since pico flags are usually pretty long, I chained a lot of UnderConstruction functions together.\nAnd lo and behold! Dumping this into CyberChef, we can see the content of the flag is being shown on the stack, separated into 4 byte chunks with reversed bit order.\nAll that\u0026rsquo;s left to do is connect remotely and see if we can extract the flag.\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/stackcache-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eUndefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/306\"\u003ethis program\u003c/a\u003e\u003c/strong\u003e to identify how you can get to the flag.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable with a buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eAnalyzing the binary, we come across some interesting funtions, \u003ccode\u003eUnderConstruction\u003c/code\u003e and \u003ccode\u003ewin\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter a quick \u003ccode\u003echecksec\u003c/code\u003e, we find vuln has both NX and a stack canary enabled.\nSo we can probably find a way to leak the stack canary using the \u003ccode\u003eUnderConstruction\u003c/code\u003e function.\u003c/p\u003e","title":"Pico Stack Cache Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 02! Navigate around the map and see what you can find!\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x.\nImmediately after that, we have the map matrix.\nFrom the main function, by solving the puzzle, which can be easily achieved by using the special command p we \u0026ldquo;win\u0026rdquo;. And with the special command l we can replace the @ player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\nIdentifying the vulnerabilities What is most likely the vulnerability is that there is no bounds check for the map, and that we can overwrite the variables on the stack by modifying one byte.\nMore precisely, using our player, and moving it out of bounds will allow us to modify the byte at position\nplayer_x + map + 90 * player_y where map is the location of the map buffer on the stack.\nWe notice a win function, so all we need to do is find a way to jump into win. Using the file command, we can see that game is a 32-bit executable, so all the function parameters are stored on the stack.\nProbably so is the return to main inside move_player, so we can set a breakpoint on its return.\nThere is no stack canary or PIE, so nothing that we need to worry about.\nAnd there it is!\nUsing hexdump with GEF, we can analyze the offset from the beginning of map to our return address (the first 0x2e being the first dot inside map). The offset seems to be 39.\nTo modify the return address we need to find a position in win that is one byte away from 0x08049709.\nFor example, 0x804975D works perfectly! So all we need to do is overwrite its LSB 09 with 5D.\nWe can easily achieve this by using the l command. So first, modify it our player to \\x5D, then we move to position map - 39.\nplayer_x + map + 90 * player_y = map - 39\nOne way to solve this is player_x = -39 and player_y = 0. To not mess with other values on the stack that might crash our program, we could first go up to player_y=-2, go to the right player_x, then go back down to player_y=0.\np.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;l\u0026#39;+b\u0026#39;\\x5D\u0026#39;) p.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;w\u0026#39;*4 + b\u0026#39;a\u0026#39;*4 + b\u0026#39;w\u0026#39;*2 +b\u0026#39;a\u0026#39;*39+b\u0026#39;s\u0026#39;*2) Some problems\u0026hellip; It seems to be working fine locally, but remotely we stumble upon another issue.\nAnd then another issue?\nIn these kinds of situations, what happens is some things get aligned differently, so the best thing to do is try other addresses near what we found.\nThe first one I found that works is \\x60, and with that we get the flag!\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame02-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/346\"\u003eBabyGame 02\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find!\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eImmediately after that, we have the \u003cstrong\u003emap matrix\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eFrom the \u003ccode\u003emain\u003c/code\u003e function, by solving the puzzle, which can be easily achieved by using the special command \u003ccode\u003ep\u003c/code\u003e we \u0026ldquo;win\u0026rdquo;. And with the special command \u003ccode\u003el\u003c/code\u003e we can replace the \u003ccode\u003e@\u003c/code\u003e player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\u003c/p\u003e","title":"Pico Babygame02 Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 03! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x and player lives.\nImmediately after that, we have the map matrix.\nWe immediately run intos a couple of problems. We need to reach level 5 to win and to print the flag (image below), but we cannot move past level 4 because of the if condition inside of the while.\nFirst, let’s worry about getting up to level 4. We notice that we have a couple of special commands inside the move_player function, Such as p to solve the level and l to change the current playertile from @.\nThe only issue with directly using the solve function is that we have a limited amount of lives/moves, and it doesn\u0026rsquo;t account for that.\nIdentifying the vulnerabilities Since the map is initialized immediately after the player lives, and there is no bounds check for the player, we can modify the tile at position map-4 (map is a 1d array from 0 to 30x90-2) so that we overwrite player_lives with 0x23 (the dot).\nplayer_arr[1] + map + 90 * player_arr basically represents the current player position on the map, and it could also be written as player_x + map + 90 * player_y.\nSo if we modify player_x to 86 and player_y to -1 we reach \u0026ldquo;player position\u0026rdquo; map-4 (out of bounds), and then we can overwrite it for unlimited lives.\nThe payload I found to reach this position (including the solve function):\npayload = b\u0026#39;www\u0026#39;+b\u0026#39;a\u0026#39;*8+b\u0026#39;wsp\u0026#39; We repeat this until we reach level 4, where things start to get a little bit more complicated.\nUsing GDB (in my case, GEF) to analyze the stack, we can find the return address of the move_player function (which is 0x804992c) \u0026ndash; by setting a breakpoint on the retn of move_player, 0x804969F, of course.\nIf we can modify that return value (which returns to main) to another address in main that comes after the level != 4 check, we can essentially reach level 5.\nIn this case, the value I chose is 0x8049970. So we only need to modify the LSB of the return value we found on the stack (we can only modify one byte, through playertile, either way).\nThe reason we can modify it is, same as player_lives, that the map array is also located on the stack, a few bytes after our return value! We can use the l command to change our playertile to \\x70.\nTo see exactly how many bytes away it is, we can use hexdump with GEF:\nAnd there it is \u0026ndash; our \\x70 value! If we count the bytes from 2c to 70, we get 51, which is the offset from the LSB to the beginning of the map (in this case our playertile was on map[0]). So we would need to go to player_y = 0 and player_x = -51.\nTo avoid getting a SEGFault by messing with all the values on the stack in between, we can first move up to player_y = -3, move to the correct x value, and then go back down to player_y = 0. And it worked!\nNow, to evade the second if problem, which keeps us in the loop, we need to change the return address from 0x804992c again. It would be nice for it to be directly in win, but since we can only modify one byte, the best value we can choose is the call to win() inside of main.\nAgain, lucky for us, that is 0x80499FE! So we modify our playertile to \\xfe, but when we repeat the same technique, something goes wrong. After inspecting the stack again, our map array shifts more towards ebp and we need to use a bigger offset to modify the return address.\nGEF\u0026rsquo;s hexdump wouldn’t show enough addresses, so I had to use this command.\nWe can see now the distance is 67 bytes, so we update the offset in our script, and voila! We got the flag!\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame03-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/446\"\u003eBabyGame 03\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame03-writeup/baby-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e and \u003cstrong\u003eplayer lives\u003c/strong\u003e.\u003c/p\u003e","title":"Pico Babygame03 Writeup"},{"content":"Challenge overview The first vuln we encounter in handoff is that it doesn\u0026rsquo;t disable NX. (Basically, this means that we can execute shellcode on the stack!)\nWe are presented with a menu with 3 options:\nAdd a recipient Send a message to a recipient Exit Upon trying to exit, we are prompted to give our feedback.\nIdentifying the vulnerability Immediately after decompiling the binary, we notice a buffer overflow in its feedback buffer. We can also see that the value at feedback[7] gets turned to \\0. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and jmp to it.\nThe perfect buffer for this is our very large message buffer! Lucky for us, rax gets the return of the previously called function (in this case gets \u0026ndash; and gets\u0026rsquo;s return is exactly our string).\nThis is because gets always returns the string it receives as input.\nSo in our feedback buffer, we need a payload that looks something like jmp addr, nop, nop, nop, until we reach rip, and then overwrite rip with a jmp rax gadget.\nObviously, our jmp addr needs to jump to our longer script, located in the message buffer, using asm(shellcraft.sh()), which will just spawn a shell for us.\nUsing ropper we find our jmp rax gadget:\njmp_rax = p64(0x40116c) We do a search-pattern of our message inside GEF, and we can find it located at $rsp - 670.\nTo find the correct offset, do the search-pattern only AFTER the script executes the jmp rax gadget (I struggled with finding the correct offset because of that for quite a bit).\nPayload Okay, so that basically means we need to do a sub rsp, 670 and a jmp rsp at the beginning of our feedback buffer. To avoid getting our payload messed up by the feedback[8] byte being changed into a null byte, we pad the payload with a few NOPs to its left.\nThen, we just adjust it to the size of the buffer overflow with NOPs, and then glue the jmp_rax gadget to its right.\npayload1 = asm(\u0026#39;nop;nop;sub rsp,670;jmp rsp;\u0026#39;) payload = payload1.ljust(20, b\u0026#39;\\x90\u0026#39;) payload += jmp_rax Don\u0026rsquo;t forget to set context.arch = 'amd64'!!! Otherwise writing assembly code won’t work.\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/handoff-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eThe first vuln we encounter in \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/486\"\u003ehandoff\u003c/a\u003e\u003c/strong\u003e is that it doesn\u0026rsquo;t disable NX.\n(Basically, this means that we can execute shellcode on the stack!)\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/handoff-writeup/handoff-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe are presented with a menu with 3 options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a recipient\u003c/li\u003e\n\u003cli\u003eSend a message to a recipient\u003c/li\u003e\n\u003cli\u003eExit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUpon trying to exit, we are prompted to give our feedback.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerability\"\u003eIdentifying the vulnerability\u003c/h2\u003e\n\u003cp\u003eImmediately after decompiling the binary, we notice a buffer overflow in its feedback buffer.\nWe can also see that the value at \u003ccode\u003efeedback[7]\u003c/code\u003e gets turned to \u003ccode\u003e\\0\u003c/code\u003e. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and \u003ccode\u003ejmp\u003c/code\u003e to it.\u003c/p\u003e","title":"Pico Handoff Writeup"}]