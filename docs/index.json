[{"content":"Challenge overview What\u0026rsquo;s ROP? Can you exploit the following program to get the flag?\nAt first glance, the vuln looks like a 32-bit executable with a buffer overflow vulnerability.\nIdentifying the vulnerabilities Analyzing the binary, it doesn\u0026rsquo;t look like anything special, just an ordinary buffer overflow.\nWe don\u0026rsquo;t seem to have a /bin/sh in memory so this probably means we have to execute a ret2reg.\nThat means we need to make our own bin/sh and point to it, and since the vuln returns the gets, that means eax will hold the gets return value. And the return value of gets is a pointer to the input value!\nThis is because eax/rax usually holds the current function\u0026rsquo;s return value.\nWould you look at that, no NX! So we can execute the code right on the stack! Since we have a large enough overflow (28 bytes), we don\u0026rsquo;t need to worry getting a shell.\nThat means we can just get a jmp eax gadget, and write our shellcraft.sh() at the start the input buffer.\nThe Exploit Well, looks like we need to write the shellcode ourselves, shellcraft.sh() was too large after all\u0026hellip;\nI tried a bunch of shellcode that kept getting me segmentation faults, that I won\u0026rsquo;t include, and I tried fitting it all in our buffer before the jmp eax gadget, and I managed to get all the registers required right (for execve, ebx needs to be a pointer to /bin/sh, and ecx and edx need to be 0)\nAfter I set the address after eip, eip+4, to be a null-terminated /bin/sh, I noticed esp would become that value.\nSo, I tried doing\nmov ebx, esp xor ecx, ecx xor edx, edx mov al, 0x0b int 0x80 And my mistake was most likely that I messed with the stack frame, since execve kept returning error 0xffffff74 = -140 = ERFAULT.\nBut then I thought, if after the jmp eax the value at eip+4 goes into esp, why don\u0026rsquo;t we write the shellcode in eip+4, then just jmp esp to said shellcode?\nThat way, we can just use shellcraft.sh(), since we have unlimited space.\nSince jmp esp is just 2 bytes, we pad with 26 more nops to its left.\npayload = b\u0026#39;\\x90\u0026#39;*26 payload += asm(\u0026#39;jmp esp\u0026#39;) payload += jmp_eax #this will become esp after we execute jmp eax. newshell = asm(shellcraft.sh()) payload += newshell And it works!\nThe rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/ropfu-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eWhat\u0026rsquo;s ROP? Can you exploit the following \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/292\"\u003eprogram\u003c/a\u003e\u003c/strong\u003e to get the flag?\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ropfu-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable with a buffer overflow vulnerability.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerabilities\"\u003eIdentifying the vulnerabilities\u003c/h2\u003e\n\u003cp\u003eAnalyzing the binary, it doesn\u0026rsquo;t look like anything special, just an ordinary buffer overflow.\u003c/p\u003e\n\u003cp\u003eWe don\u0026rsquo;t seem to have a \u003ccode\u003e/bin/sh\u003c/code\u003e in memory so this probably means we have to execute a ret2reg.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ropfu-writeup/pic3.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eThat means we need to make our own \u003ccode\u003ebin/sh\u003c/code\u003e and point to it, and since the \u003ccode\u003evuln\u003c/code\u003e \u003cem\u003ereturns\u003c/em\u003e the \u003ccode\u003egets\u003c/code\u003e, that means \u003ccode\u003eeax\u003c/code\u003e will hold the \u003ccode\u003egets\u003c/code\u003e return value. And the return value of \u003ccode\u003egets\u003c/code\u003e is a pointer to the input value!\u003c/p\u003e","title":"Pico Ropfu Writeup"},{"content":"Challenge overview Story telling class 2/2 Additional details will be available after launching your challenge instance.\nUpon a quick check, we see that the challenge is a 32-bit binary, and that we can trigger a SEGFAULT. It might be a buffer overflow, but the challenge doesn\u0026rsquo;t necessarily hint that, so let\u0026rsquo;s inspect it further.\nAlso NX is enabled, so let\u0026rsquo;s keep that in mind.\nThe first input string is not susceptible to a buffer overflow, but something interesting happens on the second scanf. We read two %d (ints), but only one destination for them (\u0026amp;number1).\nWe also have another couple of functions, hard_checker, easy_checker and calculate_story_score.\nThe check in easy_checker:\nif ( calculate_story_score(input, input_size) != 1337 ) return printf(\u0026#34;You\u0026#39;ve failed this class.\u0026#34;); The check in hard_checker:\nif ( calculate_story_score(input, input_size) != 13371337 ) return printf(\u0026#34;You\u0026#39;ve failed this class.\u0026#34;); And the calculate_story_score they both use:\nNow, inspecting with gef, let\u0026rsquo;s see where all of our values end up. For input='inputexample', nr1=7 (so it satisfies the first check) and nr2='testing'), it looks like input is being placed on the stack while the second number is getting placed on the heap.\nThe functions we stepped into were hard_checker and then calculate_story_score, so no easy_checker.\nWhat calculate_story_score does is it sums all of the ASCII characters inside our input string.\nFor our inputexample string, the output should be\nsum = 105 + 110 + 112 + 117 + 116 + 101 + 120 + 97 + 109 + 112 + 108 + 101 So, 1308. Setting a breakpoint on the return of calculate_story_score, we can see the value right there on the stack! (0x51c = 1308)\nAnd here it is, checking if it\u0026rsquo;s equal to 13371337:\nIdentifying the vulnerability So, we need to find a string that has the sum of its ASCII characters equal to 13371337. But that\u0026rsquo;s quite a big number, isn\u0026rsquo;t it? And we only have 127 bytes available.\nChars go from 0-255, so our best case scenario would be 127*255, so 32385. Not even close to 13371337 is it?\nWe could either find a way to go into easy_checker instead, or find another way to raise our sum.\nSince the challenge hint was Don\u0026rsquo;t be so negative, I\u0026rsquo;m going to assume there\u0026rsquo;s a way to integer overflow or something else to allow us to reach that number.\nOne thing we haven\u0026rsquo;t handled yet is the two numbers. What bothers me are these lines of code:\nif ( numbers \u0026lt;= 9 ) fun[number1] += v3; After trying with two numbers, (78 and 78), we can see they\u0026rsquo;re still placed in the stack and the heap respectively (I thought the second one might\u0026rsquo;ve ended up on the heap because I gave it too large a value, but it wasn\u0026rsquo;t the case).\nDebugging Detour Before actually figuring out how to solve this challenge, I wasted a surprising amount of time due to a small mistake, which is that I kept using a string value for the second %d argument. Since scanf(\u0026quot;%d\u0026quot;) interprets 4-byte integers, my string \u0026quot;testing\u0026quot; became some random hex bytes that I misinterpreted as something hardcoded.\nBecause of that, I spent a lot of time trying to find ways to overwrite the ASCII sum, manipulate the comparison instruction, overwrite .rodata, or patch return addresses, so a couple of hours in gef and a lot of SEGFAULTS. Turns out the specific hex value was literally just the second integer, which I had broken it myself by feeding it a string.\nAnd also the challenge had nothing to do with the heap either.\nSo maybe the lesson to be learned is to be a lot more careful with \u0026ldquo;testing\u0026rdquo; input values.\nThe exploit Let\u0026rsquo;s take a look at the assembly code for this if:\nmov eax, [ebp+number1] #eax = number1 mov ecx, ds:(fun - 804C000h)[ebx+eax*4] #ecx = fun[number1] mov edx, [ebp+var_90] # edx = number2 mov eax, [ebp+number1] # eax = numbers add edx, ecx # edx += ecx mov ds:(fun - 804C000h)[ebx+eax*4], edx # fun[number1] = edx Or more simply put,\nfun_table[number1 * 4] += number2; Here we can see number2 getting loaded into edx. And ebx + 0x80 is just the address of fun.\nHere is fun in .data, located at 0804C080.\nAnother interesting thing was how the hard_checker function was called:\nv0 = check; return v0((int)input, input_size); Where check holds the address of hard_checker: 0x804c040 \u0026lt;check\u0026gt;: 0x08049436\nAnd guess what, check is, just like fun, located in the .rodata!\nSince the condition in hard_checker was sum == 13371337, which is impossibe to reach, and we have a similar function called easy_checker that presents us with a much more attainable sum == 1337, we can already guess we are supposed to somehow modify the address in check from hard_checker to easy_checker.\nSince we can choose a negative [numbers] index, we can modify data out of bounds to control the value of check.\nDouble checking with vmmap, the area is rw, so we can modify values!\n0x0804c000 0x0804d000 0x00003000 rw- /home/kali/Downloads/vuln\nOkay, so\nfun - check is 0x804C080 - 0x804C040,\nwhich is 0x40.\nSince we need to modify fun[-0x40], that meansnumber1*4 should be -0x40 = -64. So we already figured out number1 = -16.\nTaking care of the sum, our inputexample was already close to 1337. 1337 - 1308 = 29, so instead of e (101 ASCII) I added two A\u0026rsquo;s (65+65 = 101 +29).\nNow, to figure out number2, we just need to calculate the offset between hard_checker and easy_checker.\nhard_checker : 0x08049436\neasy_checker : 0x80492FC\nSo out offset is -0x13A, -314 in hex.\nAnd we\u0026rsquo;re done!\nThe rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/functionoverwrite-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eStory telling class 2/2\nAdditional details will be available after launching your \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/272\"\u003echallenge instance\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/functionoverwrite-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eUpon a quick check, we see that the challenge is a \u003ccode\u003e32-bit\u003c/code\u003e binary, and that we can trigger a \u003ccode\u003eSEGFAULT\u003c/code\u003e. It might be a buffer overflow, but the challenge doesn\u0026rsquo;t necessarily hint that, so let\u0026rsquo;s inspect it further.\u003c/p\u003e\n\u003cp\u003eAlso NX is enabled, so let\u0026rsquo;s keep that in mind.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/functionoverwrite-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eThe first input string is not susceptible to a buffer overflow, but something interesting happens on the second \u003ccode\u003escanf\u003c/code\u003e. We read two \u003ccode\u003e%d\u003c/code\u003e (ints), but only one destination for them (\u003ccode\u003e\u0026amp;number1\u003c/code\u003e).\u003c/p\u003e","title":"Pico Function Overwrite Writeup"},{"content":"Challenge overview Undefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse this program to identify how you can get to the flag.\nAt first glance, the vuln looks like a 32-bit executable with a buffer overflow vulnerability.\nAnalyzing the binary, we come across some interesting funtions, UnderConstruction and win.\nAfter a quick checksec, we find vuln has both NX and a stack canary enabled. So we can probably find a way to leak the stack canary using the UnderConstruction function.\nIdentifying the vulnerabilities We can easily buffer overflow (the offset I used was 14 of \\x90 padding and then I set the new eip as 0x8049E10, the beginning of UnderConstruction) into UnderConstruction, and we get a bunch of leaks:\nIt doesn\u0026rsquo;t seem like the stack canary is very effective. If we overwrite eip with the win function, it does indeed enter win, but no flag seems to be getting printed. Let\u0026rsquo;s analyze it further:\nAha! So if we look closely, what this does is it saves the flag in the stack, and if the flag array is null, it executes a _printf(%s %s);.\nIn my case, I have a flag.txt file created locally, so it doesn\u0026rsquo;t really output anything at all. What it does do though, is save the flag in the stack (also hinted by the challenge name, stack cache).\nWe can see the content of flag.txt being pushed on the stack.\nThe next logical step is making it so that the function called after win is UnderConstruction. We can do this without much hassle since we are working on a 32-bit executable, so no need to work with registers.\nThe stack alignment for 32-bit is function, parameters, return address and since these functions don\u0026rsquo;t need any params we can easily chain a bunch of functions.\npayload = b\u0026#39;\\x90\u0026#39;*14 payload += p32(0x8049D90) #win payload += p32(0x8049E10) #under constr devine ret addr la win payload += p32(0x8049E10) #a bunch of undr constr to leak the flag payload += p32(0x8049E10) #to get a bunch of %p \u0026#39;s payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049EB0) #main Since I wanted to make sure that we would get all of the flag, not just a part of it, since pico flags are usually pretty long, I chained a lot of UnderConstruction functions together.\nAnd lo and behold! Dumping this into CyberChef, we can see the content of the flag is being shown on the stack, separated into 4 byte chunks with reversed bit order.\nAll that\u0026rsquo;s left to do is connect remotely and see if we can extract the flag.\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/stackcache-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eUndefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/306\"\u003ethis program\u003c/a\u003e\u003c/strong\u003e to identify how you can get to the flag.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable with a buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eAnalyzing the binary, we come across some interesting funtions, \u003ccode\u003eUnderConstruction\u003c/code\u003e and \u003ccode\u003ewin\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter a quick \u003ccode\u003echecksec\u003c/code\u003e, we find vuln has both NX and a stack canary enabled.\nSo we can probably find a way to leak the stack canary using the \u003ccode\u003eUnderConstruction\u003c/code\u003e function.\u003c/p\u003e","title":"Pico Stack Cache Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 02! Navigate around the map and see what you can find!\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x.\nImmediately after that, we have the map matrix.\nFrom the main function, by solving the puzzle, which can be easily achieved by using the special command p we \u0026ldquo;win\u0026rdquo;. And with the special command l we can replace the @ player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\nIdentifying the vulnerabilities What is most likely the vulnerability is that there is no bounds check for the map, and that we can overwrite the variables on the stack by modifying one byte.\nMore precisely, using our player, and moving it out of bounds will allow us to modify the byte at position\nplayer_x + map + 90 * player_y where map is the location of the map buffer on the stack.\nWe notice a win function, so all we need to do is find a way to jump into win. Using the file command, we can see that game is a 32-bit executable, so all the function parameters are stored on the stack.\nProbably so is the return to main inside move_player, so we can set a breakpoint on its return.\nThere is no stack canary or PIE, so nothing that we need to worry about.\nAnd there it is!\nUsing hexdump with GEF, we can analyze the offset from the beginning of map to our return address (the first 0x2e being the first dot inside map). The offset seems to be 39.\nTo modify the return address we need to find a position in win that is one byte away from 0x08049709.\nFor example, 0x804975D works perfectly! So all we need to do is overwrite its LSB 09 with 5D.\nWe can easily achieve this by using the l command. So first, modify it our player to \\x5D, then we move to position map - 39.\nplayer_x + map + 90 * player_y = map - 39\nOne way to solve this is player_x = -39 and player_y = 0. To not mess with other values on the stack that might crash our program, we could first go up to player_y=-2, go to the right player_x, then go back down to player_y=0.\np.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;l\u0026#39;+b\u0026#39;\\x5D\u0026#39;) p.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;w\u0026#39;*4 + b\u0026#39;a\u0026#39;*4 + b\u0026#39;w\u0026#39;*2 +b\u0026#39;a\u0026#39;*39+b\u0026#39;s\u0026#39;*2) Some problems\u0026hellip; It seems to be working fine locally, but remotely we stumble upon another issue.\nAnd then another issue?\nIn these kinds of situations, what happens is some things get aligned differently, so the best thing to do is try other addresses near what we found.\nThe first one I found that works is \\x60, and with that we get the flag!\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame02-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/346\"\u003eBabyGame 02\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find!\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eImmediately after that, we have the \u003cstrong\u003emap matrix\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eFrom the \u003ccode\u003emain\u003c/code\u003e function, by solving the puzzle, which can be easily achieved by using the special command \u003ccode\u003ep\u003c/code\u003e we \u0026ldquo;win\u0026rdquo;. And with the special command \u003ccode\u003el\u003c/code\u003e we can replace the \u003ccode\u003e@\u003c/code\u003e player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\u003c/p\u003e","title":"Pico Babygame02 Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 03! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x and player lives.\nImmediately after that, we have the map matrix.\nWe immediately run intos a couple of problems. We need to reach level 5 to win and to print the flag (image below), but we cannot move past level 4 because of the if condition inside of the while.\nFirst, let’s worry about getting up to level 4. We notice that we have a couple of special commands inside the move_player function, Such as p to solve the level and l to change the current playertile from @.\nThe only issue with directly using the solve function is that we have a limited amount of lives/moves, and it doesn\u0026rsquo;t account for that.\nIdentifying the vulnerabilities Since the map is initialized immediately after the player lives, and there is no bounds check for the player, we can modify the tile at position map-4 (map is a 1d array from 0 to 30x90-2) so that we overwrite player_lives with 0x23 (the dot).\nplayer_arr[1] + map + 90 * player_arr basically represents the current player position on the map, and it could also be written as player_x + map + 90 * player_y.\nSo if we modify player_x to 86 and player_y to -1 we reach \u0026ldquo;player position\u0026rdquo; map-4 (out of bounds), and then we can overwrite it for unlimited lives.\nThe payload I found to reach this position (including the solve function):\npayload = b\u0026#39;www\u0026#39;+b\u0026#39;a\u0026#39;*8+b\u0026#39;wsp\u0026#39; We repeat this until we reach level 4, where things start to get a little bit more complicated.\nUsing GDB (in my case, GEF) to analyze the stack, we can find the return address of the move_player function (which is 0x804992c) \u0026ndash; by setting a breakpoint on the retn of move_player, 0x804969F, of course.\nIf we can modify that return value (which returns to main) to another address in main that comes after the level != 4 check, we can essentially reach level 5.\nIn this case, the value I chose is 0x8049970. So we only need to modify the LSB of the return value we found on the stack (we can only modify one byte, through playertile, either way).\nThe reason we can modify it is, same as player_lives, that the map array is also located on the stack, a few bytes after our return value! We can use the l command to change our playertile to \\x70.\nTo see exactly how many bytes away it is, we can use hexdump with GEF:\nAnd there it is \u0026ndash; our \\x70 value! If we count the bytes from 2c to 70, we get 51, which is the offset from the LSB to the beginning of the map (in this case our playertile was on map[0]). So we would need to go to player_y = 0 and player_x = -51.\nTo avoid getting a SEGFault by messing with all the values on the stack in between, we can first move up to player_y = -3, move to the correct x value, and then go back down to player_y = 0. And it worked!\nNow, to evade the second if problem, which keeps us in the loop, we need to change the return address from 0x804992c again. It would be nice for it to be directly in win, but since we can only modify one byte, the best value we can choose is the call to win() inside of main.\nAgain, lucky for us, that is 0x80499FE! So we modify our playertile to \\xfe, but when we repeat the same technique, something goes wrong. After inspecting the stack again, our map array shifts more towards ebp and we need to use a bigger offset to modify the return address.\nGEF\u0026rsquo;s hexdump wouldn’t show enough addresses, so I had to use this command.\nWe can see now the distance is 67 bytes, so we update the offset in our script, and voila! We got the flag!\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame03-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/446\"\u003eBabyGame 03\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame03-writeup/baby-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e and \u003cstrong\u003eplayer lives\u003c/strong\u003e.\u003c/p\u003e","title":"Pico Babygame03 Writeup"},{"content":"Challenge overview The first vuln we encounter in handoff is that it doesn\u0026rsquo;t disable NX. (Basically, this means that we can execute shellcode on the stack!)\nWe are presented with a menu with 3 options:\nAdd a recipient Send a message to a recipient Exit Upon trying to exit, we are prompted to give our feedback.\nIdentifying the vulnerability Immediately after decompiling the binary, we notice a buffer overflow in its feedback buffer. We can also see that the value at feedback[7] gets turned to \\0. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and jmp to it.\nThe perfect buffer for this is our very large message buffer! Lucky for us, rax gets the return of the previously called function (in this case gets \u0026ndash; and gets\u0026rsquo;s return is exactly our string).\nThis is because gets always returns the string it receives as input.\nSo in our feedback buffer, we need a payload that looks something like jmp addr, nop, nop, nop, until we reach rip, and then overwrite rip with a jmp rax gadget.\nObviously, our jmp addr needs to jump to our longer script, located in the message buffer, using asm(shellcraft.sh()), which will just spawn a shell for us.\nUsing ropper we find our jmp rax gadget:\njmp_rax = p64(0x40116c) We do a search-pattern of our message inside GEF, and we can find it located at $rsp - 670.\nTo find the correct offset, do the search-pattern only AFTER the script executes the jmp rax gadget (I struggled with finding the correct offset because of that for quite a bit).\nPayload Okay, so that basically means we need to do a sub rsp, 670 and a jmp rsp at the beginning of our feedback buffer. To avoid getting our payload messed up by the feedback[8] byte being changed into a null byte, we pad the payload with a few NOPs to its left.\nThen, we just adjust it to the size of the buffer overflow with NOPs, and then glue the jmp_rax gadget to its right.\npayload1 = asm(\u0026#39;nop;nop;sub rsp,670;jmp rsp;\u0026#39;) payload = payload1.ljust(20, b\u0026#39;\\x90\u0026#39;) payload += jmp_rax Don\u0026rsquo;t forget to set context.arch = 'amd64'!!! Otherwise writing assembly code won’t work.\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/handoff-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eThe first vuln we encounter in \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/486\"\u003ehandoff\u003c/a\u003e\u003c/strong\u003e is that it doesn\u0026rsquo;t disable NX.\n(Basically, this means that we can execute shellcode on the stack!)\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/handoff-writeup/handoff-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe are presented with a menu with 3 options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a recipient\u003c/li\u003e\n\u003cli\u003eSend a message to a recipient\u003c/li\u003e\n\u003cli\u003eExit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUpon trying to exit, we are prompted to give our feedback.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerability\"\u003eIdentifying the vulnerability\u003c/h2\u003e\n\u003cp\u003eImmediately after decompiling the binary, we notice a buffer overflow in its feedback buffer.\nWe can also see that the value at \u003ccode\u003efeedback[7]\u003c/code\u003e gets turned to \u003ccode\u003e\\0\u003c/code\u003e. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and \u003ccode\u003ejmp\u003c/code\u003e to it.\u003c/p\u003e","title":"Pico Handoff Writeup"}]