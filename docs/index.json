[{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 03! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x and player lives.\nImmediately after that, we have the map matrix.\nWe immediately run intos a couple of problems. We need to reach level 5 to win and to print the flag (image below), but we cannot move past level 4 because of the if condition inside of the while.\nFirst, let’s worry about getting up to level 4. We notice that we have a couple of special commands inside the move_player function, Such as p to solve the level and l to change the current playertile from @.\nThe only issue with directly using the solve function is that we have a limited amount of lives/moves, and it doesn\u0026rsquo;t account for that.\nIdentifying the vulnerabilities Since the map is initialized immediately after the player lives, and there is no bounds check for the player, we can modify the tile at position map-4 (map is a 1d array from 0 to 30x90-2) so that we overwrite player_lives with 0x23 (the dot).\nplayer_arr[1] + map + 90 * player_arr basically represents the current player position on the map, and it could also be written as player_x + map + 90 * player_y.\nSo if we modify player_x to 86 and player_y to -1 we reach \u0026ldquo;player position\u0026rdquo; map-4 (out of bounds), and then we can overwrite it for unlimited lives.\nThe payload I found to reach this position (including the solve function):\npayload = b\u0026#39;www\u0026#39;+b\u0026#39;a\u0026#39;*8+b\u0026#39;wsp\u0026#39; We repeat this until we reach level 4, where things start to get a little bit more complicated.\nUsing GDB (in my case, GEF) to analyze the stack, we can find the return address of the move_player function (which is 0x804992c) \u0026ndash; by setting a breakpoint on the retn of move_player, 0x804969F, of course.\nIf we can modify that return value (which returns to main) to another address in main that comes after the level != 4 check, we can essentially reach level 5.\nIn this case, the value I chose is 0x8049970. So we only need to modify the LSB of the return value we found on the stack (we can only modify one byte, through playertile, either way).\nThe reason we can modify it is, same as player_lives, that the map array is also located on the stack, a few bytes after our return value! We can use the l command to change our playertile to \\x70.\nTo see exactly how many bytes away it is, we can use hexdump with GEF:\nAnd there it is \u0026ndash; our \\x70 value! If we count the bytes from 2c to 70, we get 51, which is the offset from the LSB to the beginning of the map (in this case our playertile was on map[0]). So we would need to go to player_y = 0 and player_x = -51.\nTo avoid getting a SEGFault by messing with all the values on the stack in between, we can first move up to player_y = -3, move to the correct x value, and then go back down to player_y = 0. And it worked!\nNow, to evade the second if problem, which keeps us in the loop, we need to change the return address from 0x804992c again. It would be nice for it to be directly in win, but since we can only modify one byte, the best value we can choose is the call to win() inside of main.\nAgain, lucky for us, that is 0x80499FE! So we modify our playertile to \\xfe, but when we repeat the same technique, something goes wrong. After inspecting the stack again, our map array shifts more towards ebp and we need to use a bigger offset to modify the return address.\nGEF\u0026rsquo;s hexdump wouldn’t show enough addresses, so I had to use this command.\nWe can see now the distance is 67 bytes, so we update the offset in our script, and voila! We got the flag!\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame03-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/446\"\u003eBabyGame 03\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame03-writeup/baby-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e and \u003cstrong\u003eplayer lives\u003c/strong\u003e.\u003c/p\u003e","title":"Pico Babygame03 Writeup"},{"content":"Challenge overview The first vuln we encounter in handoff is that it doesn\u0026rsquo;t disable NX. (Basically, this means that we can execute shellcode on the stack!)\nWe are presented with a menu with 3 options:\nAdd a recipient Send a message to a recipient Exit Upon trying to exit, we are prompted to give our feedback.\nIdentifying the vulnerability Immediately after decompiling the binary, we notice a buffer overflow in its feedback buffer. We can also see that the value at feedback[7] gets turned to \\0. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and jmp to it.\nThe perfect buffer for this is our very large message buffer! Lucky for us, rax gets the return of the previously called function (in this case gets \u0026ndash; and gets\u0026rsquo;s return is exactly our string).\nThis is because gets always returns the string it receives as input.\nSo in our feedback buffer, we need a payload that looks something like jmp addr, nop, nop, nop, until we reach rip, and then overwrite rip with a jmp rax gadget.\nObviously, our jmp addr needs to jump to our longer script, located in the message buffer, using asm(shellcraft.sh()), which will just spawn a shell for us.\nUsing ropper we find our jmp rax gadget:\njmp_rax = p64(0x40116c) We do a search-pattern of our message inside GEF, and we can find it located at $rsp - 670.\nTo find the correct offset, do the search-pattern only AFTER the script executes the jmp rax gadget (I struggled with finding the correct offset because of that for quite a bit).\nPayload Okay, so that basically means we need to do a sub rsp, 670 and a jmp rsp at the beginning of our feedback buffer. To avoid getting our payload messed up by the feedback[8] byte being changed into a null byte, we pad the payload with a few NOPs to its left.\nThen, we just adjust it to the size of the buffer overflow with NOPs, and then glue the jmp_rax gadget to its right.\npayload1 = asm(\u0026#39;nop;nop;sub rsp,670;jmp rsp;\u0026#39;) payload = payload1.ljust(20, b\u0026#39;\\x90\u0026#39;) payload += jmp_rax Don\u0026rsquo;t forget to set context.arch = 'amd64'!!! Otherwise writing assembly code won’t work.\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/handoff-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eThe first vuln we encounter in \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/486\"\u003ehandoff\u003c/a\u003e\u003c/strong\u003e is that it doesn\u0026rsquo;t disable NX.\n(Basically, this means that we can execute shellcode on the stack!)\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/handoff-writeup/handoff-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe are presented with a menu with 3 options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a recipient\u003c/li\u003e\n\u003cli\u003eSend a message to a recipient\u003c/li\u003e\n\u003cli\u003eExit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUpon trying to exit, we are prompted to give our feedback.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerability\"\u003eIdentifying the vulnerability\u003c/h2\u003e\n\u003cp\u003eImmediately after decompiling the binary, we notice a buffer overflow in its feedback buffer.\nWe can also see that the value at \u003ccode\u003efeedback[7]\u003c/code\u003e gets turned to \u003ccode\u003e\\0\u003c/code\u003e. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and \u003ccode\u003ejmp\u003c/code\u003e to it.\u003c/p\u003e","title":"Pico Handoff Writeup"}]